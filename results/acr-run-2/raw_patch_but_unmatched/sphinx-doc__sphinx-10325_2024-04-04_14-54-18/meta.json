{
    "task_id": "sphinx-doc__sphinx-10325",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/sphinx-doc__sphinx/setup_sphinx-doc__sphinx__5.0",
        "env_name": "setup_sphinx-doc__sphinx__5.0",
        "pre_install": [
            "sed -i 's/pytest/pytest -rA/' tox.ini"
        ],
        "install": "python -m pip install -e .[test]",
        "test_cmd": "tox -epy39 -v -- tests/roots/test-ext-autodoc/target/inheritance.py tests/test_ext_autodoc_automodule.py"
    },
    "task_info": {
        "instance_id": "sphinx-doc__sphinx-10325",
        "base_commit": "7bdc11e87c7d86dcc2a087eccb7a7c129a473415",
        "hints_text": "+1: Acceptable change.\n>A class inherits from multiple other classes. I want to document members from some of the base classes but ignore some of the base classes\r\n\r\nFor example, there is a class that inherits multiple base classes:\r\n```\r\nclass MyClass(Parent1, Parent2, Parent3, ...):\r\n    pass\r\n```\r\nand\r\n\r\n```\r\n.. autoclass:: example.MyClass\r\n   :inherited-members: Parent2\r\n```\r\n\r\nHow should the new `:inherited-members:` work? Do you mean that the member of Parent2 are ignored and the Parent1's and Parent3's are documented? And how about the methods of the super classes of `Parent1`?\r\n\r\nNote: The current behavior is ignoring Parent2, Parent3, and the super classes of them (including Parent1's also). In python words, the classes after `Parent2` in MRO list are all ignored.",
        "created_at": "2022-04-02T17:05:02Z",
        "test_patch": "diff --git a/tests/roots/test-ext-autodoc/target/inheritance.py b/tests/roots/test-ext-autodoc/target/inheritance.py\n--- a/tests/roots/test-ext-autodoc/target/inheritance.py\n+++ b/tests/roots/test-ext-autodoc/target/inheritance.py\n@@ -15,3 +15,8 @@ class Derived(Base):\n     def inheritedmeth(self):\n         # no docstring here\n         pass\n+\n+\n+class MyList(list):\n+    def meth(self):\n+        \"\"\"docstring\"\"\"\ndiff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -113,6 +113,68 @@ def test_automodule_special_members(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_inherited_members(app):\n+    if sys.version_info < (3, 7):\n+        args = ''\n+    else:\n+        args = '(iterable=(), /)'\n+\n+    options = {'members': None,\n+               'undoc-members': None,\n+               'inherited-members': 'Base, list'}\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.inheritance',\n+        '',\n+        '',\n+        '.. py:class:: Base()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedclassmeth()',\n+        '      :module: target.inheritance',\n+        '      :classmethod:',\n+        '',\n+        '      Inherited class method.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedstaticmeth(cls)',\n+        '      :module: target.inheritance',\n+        '      :staticmethod:',\n+        '',\n+        '      Inherited static method.',\n+        '',\n+        '',\n+        '.. py:class:: Derived()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Derived.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '.. py:class:: MyList%s' % args,\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: MyList.meth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n                                                             'missing_package1',\n",
        "repo": "sphinx-doc/sphinx",
        "problem_statement": "inherited-members should support more than one class\n**Is your feature request related to a problem? Please describe.**\r\nI have two situations:\r\n- A class inherits from multiple other classes. I want to document members from some of the base classes but ignore some of the base classes\r\n- A module contains several class definitions that inherit from different classes that should all be ignored (e.g., classes that inherit from list or set or tuple). I want to ignore members from list, set, and tuple while documenting all other inherited members in classes in the module.\r\n\r\n**Describe the solution you'd like**\r\nThe :inherited-members: option to automodule should accept a list of classes. If any of these classes are encountered as base classes when instantiating autoclass documentation, they should be ignored.\r\n\r\n**Describe alternatives you've considered**\r\nThe alternative is to not use automodule, but instead manually enumerate several autoclass blocks for a module. This only addresses the second bullet in the problem description and not the first. It is also tedious for modules containing many class definitions.\r\n\r\n\n",
        "version": "5.0",
        "FAIL_TO_PASS": [
            "tests/test_ext_autodoc_automodule.py::test_automodule_inherited_members"
        ],
        "PASS_TO_PASS": [
            "tests/test_ext_autodoc_automodule.py::test_automodule",
            "tests/test_ext_autodoc_automodule.py::test_automodule_special_members",
            "tests/test_ext_autodoc_automodule.py::test_automodule_undoc_members",
            "tests/test_ext_autodoc_automodule.py::test_empty_all",
            "tests/test_ext_autodoc_automodule.py::test_subclass_of_mocked_object"
        ],
        "environment_setup_commit": "60775ec4c4ea08509eee4b564cbf90f316021aff",
        "patch": "diff --git a/sphinx/ext/autodoc/__init__.py b/sphinx/ext/autodoc/__init__.py\n--- a/sphinx/ext/autodoc/__init__.py\n+++ b/sphinx/ext/autodoc/__init__.py\n@@ -109,12 +109,14 @@ def exclude_members_option(arg: Any) -> Union[object, Set[str]]:\n     return {x.strip() for x in arg.split(',') if x.strip()}\n \n \n-def inherited_members_option(arg: Any) -> Union[object, Set[str]]:\n+def inherited_members_option(arg: Any) -> Set[str]:\n     \"\"\"Used to convert the :members: option to auto directives.\"\"\"\n     if arg in (None, True):\n-        return 'object'\n+        return {'object'}\n+    elif arg:\n+        return set(x.strip() for x in arg.split(','))\n     else:\n-        return arg\n+        return set()\n \n \n def member_order_option(arg: Any) -> Optional[str]:\n@@ -680,9 +682,11 @@ def filter_members(self, members: ObjectMembers, want_all: bool\n         ``autodoc-skip-member`` event.\n         \"\"\"\n         def is_filtered_inherited_member(name: str, obj: Any) -> bool:\n+            inherited_members = self.options.inherited_members or set()\n+\n             if inspect.isclass(self.object):\n                 for cls in self.object.__mro__:\n-                    if cls.__name__ == self.options.inherited_members and cls != self.object:\n+                    if cls.__name__ in inherited_members and cls != self.object:\n                         # given member is a member of specified *super class*\n                         return True\n                     elif name in cls.__dict__:\n",
        "pr_link": "https://github.com/sphinx-doc/sphinx/pull/10325"
    }
}