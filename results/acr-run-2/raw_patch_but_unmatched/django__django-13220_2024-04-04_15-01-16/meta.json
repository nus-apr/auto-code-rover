{
    "task_id": "django__django-13220",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/django__django/setup_django__django__3.2",
        "env_name": "setup_django__django__3.2",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "./tests/runtests.py --verbosity 2 test_exceptions.test_validation_error"
    },
    "task_info": {
        "instance_id": "django__django-13220",
        "base_commit": "16218c20606d8cd89c5393970c83da04598a3e04",
        "hints_text": "I probably wouldn't want to limit the comparison to an error's message but rather to its full set of attributes (message, code, params). While params is always pushed into message when iterating over the errors in an ValidationError, I believe it can be beneficial to know if the params that were put inside are the same.\n\u200bPR",
        "created_at": "2020-07-21T19:54:16Z",
        "test_patch": "diff --git a/tests/test_exceptions/test_validation_error.py b/tests/test_exceptions/test_validation_error.py\n--- a/tests/test_exceptions/test_validation_error.py\n+++ b/tests/test_exceptions/test_validation_error.py\n@@ -1,4 +1,5 @@\n import unittest\n+from unittest import mock\n \n from django.core.exceptions import ValidationError\n \n@@ -14,3 +15,271 @@ def test_messages_concatenates_error_dict_values(self):\n         message_dict['field2'] = ['E3', 'E4']\n         exception = ValidationError(message_dict)\n         self.assertEqual(sorted(exception.messages), ['E1', 'E2', 'E3', 'E4'])\n+\n+    def test_eq(self):\n+        error1 = ValidationError('message')\n+        error2 = ValidationError('message', code='my_code1')\n+        error3 = ValidationError('message', code='my_code2')\n+        error4 = ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )\n+        error5 = ValidationError({'field1': 'message', 'field2': 'other'})\n+        error6 = ValidationError({'field1': 'message'})\n+        error7 = ValidationError([\n+            ValidationError({'field1': 'field error', 'field2': 'other'}),\n+            'message',\n+        ])\n+\n+        self.assertEqual(error1, ValidationError('message'))\n+        self.assertNotEqual(error1, ValidationError('message2'))\n+        self.assertNotEqual(error1, error2)\n+        self.assertNotEqual(error1, error4)\n+        self.assertNotEqual(error1, error5)\n+        self.assertNotEqual(error1, error6)\n+        self.assertNotEqual(error1, error7)\n+        self.assertEqual(error1, mock.ANY)\n+        self.assertEqual(error2, ValidationError('message', code='my_code1'))\n+        self.assertNotEqual(error2, ValidationError('other', code='my_code1'))\n+        self.assertNotEqual(error2, error3)\n+        self.assertNotEqual(error2, error4)\n+        self.assertNotEqual(error2, error5)\n+        self.assertNotEqual(error2, error6)\n+        self.assertNotEqual(error2, error7)\n+\n+        self.assertEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code2',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val1', 'parm1': 'val2'},\n+        ))\n+        self.assertNotEqual(error4, ValidationError(\n+            'error val1 val2',\n+            code='my_code1',\n+        ))\n+        # params ordering is ignored.\n+        self.assertEqual(error4, ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2', 'parm1': 'val1'},\n+        ))\n+\n+        self.assertEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field2': 'other'}),\n+        )\n+        self.assertNotEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field2': 'other2'}),\n+        )\n+        self.assertNotEqual(\n+            error5,\n+            ValidationError({'field1': 'message', 'field3': 'other'}),\n+        )\n+        self.assertNotEqual(error5, error6)\n+        # fields ordering is ignored.\n+        self.assertEqual(\n+            error5,\n+            ValidationError({'field2': 'other', 'field1': 'message'}),\n+        )\n+\n+        self.assertNotEqual(error7, ValidationError(error7.error_list[1:]))\n+        self.assertNotEqual(\n+            ValidationError(['message']),\n+            ValidationError([ValidationError('message', code='my_code')]),\n+        )\n+        # messages ordering is ignored.\n+        self.assertEqual(\n+            error7,\n+            ValidationError(list(reversed(error7.error_list))),\n+        )\n+\n+        self.assertNotEqual(error4, ValidationError([error4]))\n+        self.assertNotEqual(ValidationError([error4]), error4)\n+        self.assertNotEqual(error4, ValidationError({'field1': error4}))\n+        self.assertNotEqual(ValidationError({'field1': error4}), error4)\n+\n+    def test_eq_nested(self):\n+        error_dict = {\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm1': 'val1', 'parm2': 'val2'},\n+            ),\n+            'field2': 'other',\n+        }\n+        error = ValidationError(error_dict)\n+        self.assertEqual(error, ValidationError(dict(error_dict)))\n+        self.assertEqual(error, ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm2': 'val2', 'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }))\n+        self.assertNotEqual(error, ValidationError(\n+            {**error_dict, 'field2': 'message'},\n+        ))\n+        self.assertNotEqual(error, ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s val2',\n+                code='my_code',\n+                params={'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }))\n+\n+    def test_hash(self):\n+        error1 = ValidationError('message')\n+        error2 = ValidationError('message', code='my_code1')\n+        error3 = ValidationError('message', code='my_code2')\n+        error4 = ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )\n+        error5 = ValidationError({'field1': 'message', 'field2': 'other'})\n+        error6 = ValidationError({'field1': 'message'})\n+        error7 = ValidationError([\n+            ValidationError({'field1': 'field error', 'field2': 'other'}),\n+            'message',\n+        ])\n+\n+        self.assertEqual(hash(error1), hash(ValidationError('message')))\n+        self.assertNotEqual(hash(error1), hash(ValidationError('message2')))\n+        self.assertNotEqual(hash(error1), hash(error2))\n+        self.assertNotEqual(hash(error1), hash(error4))\n+        self.assertNotEqual(hash(error1), hash(error5))\n+        self.assertNotEqual(hash(error1), hash(error6))\n+        self.assertNotEqual(hash(error1), hash(error7))\n+        self.assertEqual(\n+            hash(error2),\n+            hash(ValidationError('message', code='my_code1')),\n+        )\n+        self.assertNotEqual(\n+            hash(error2),\n+            hash(ValidationError('other', code='my_code1')),\n+        )\n+        self.assertNotEqual(hash(error2), hash(error3))\n+        self.assertNotEqual(hash(error2), hash(error4))\n+        self.assertNotEqual(hash(error2), hash(error5))\n+        self.assertNotEqual(hash(error2), hash(error6))\n+        self.assertNotEqual(hash(error2), hash(error7))\n+\n+        self.assertEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code2',\n+            params={'parm1': 'val1', 'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val1', 'parm1': 'val2'},\n+        )))\n+        self.assertNotEqual(hash(error4), hash(ValidationError(\n+            'error val1 val2',\n+            code='my_code1',\n+        )))\n+        # params ordering is ignored.\n+        self.assertEqual(hash(error4), hash(ValidationError(\n+            'error %(parm1)s %(parm2)s',\n+            code='my_code1',\n+            params={'parm2': 'val2', 'parm1': 'val1'},\n+        )))\n+\n+        self.assertEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field2': 'other'})),\n+        )\n+        self.assertNotEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field2': 'other2'})),\n+        )\n+        self.assertNotEqual(\n+            hash(error5),\n+            hash(ValidationError({'field1': 'message', 'field3': 'other'})),\n+        )\n+        self.assertNotEqual(error5, error6)\n+        # fields ordering is ignored.\n+        self.assertEqual(\n+            hash(error5),\n+            hash(ValidationError({'field2': 'other', 'field1': 'message'})),\n+        )\n+\n+        self.assertNotEqual(\n+            hash(error7),\n+            hash(ValidationError(error7.error_list[1:])),\n+        )\n+        self.assertNotEqual(\n+            hash(ValidationError(['message'])),\n+            hash(ValidationError([ValidationError('message', code='my_code')])),\n+        )\n+        # messages ordering is ignored.\n+        self.assertEqual(\n+            hash(error7),\n+            hash(ValidationError(list(reversed(error7.error_list)))),\n+        )\n+\n+        self.assertNotEqual(hash(error4), hash(ValidationError([error4])))\n+        self.assertNotEqual(hash(ValidationError([error4])), hash(error4))\n+        self.assertNotEqual(\n+            hash(error4),\n+            hash(ValidationError({'field1': error4})),\n+        )\n+\n+    def test_hash_nested(self):\n+        error_dict = {\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm2': 'val2', 'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        }\n+        error = ValidationError(error_dict)\n+        self.assertEqual(hash(error), hash(ValidationError(dict(error_dict))))\n+        self.assertEqual(hash(error), hash(ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s %(parm2)s',\n+                code='my_code',\n+                params={'parm1': 'val1', 'parm2': 'val2'},\n+            ),\n+            'field2': 'other',\n+        })))\n+        self.assertNotEqual(hash(error), hash(ValidationError(\n+            {**error_dict, 'field2': 'message'},\n+        )))\n+        self.assertNotEqual(hash(error), hash(ValidationError({\n+            'field1': ValidationError(\n+                'error %(parm1)s val2',\n+                code='my_code',\n+                params={'parm1': 'val1'},\n+            ),\n+            'field2': 'other',\n+        })))\n",
        "repo": "django/django",
        "problem_statement": "Allow ValidationErrors to equal each other when created identically\nDescription\n\t \n\t\t(last modified by kamni)\n\t \nCurrently ValidationErrors (django.core.exceptions.ValidationError) that have identical messages don't equal each other, which is counter-intuitive, and can make certain kinds of testing more complicated. Please add an __eq__ method that allows two ValidationErrors to be compared. \nIdeally, this would be more than just a simple self.messages == other.messages. It would be most helpful if the comparison were independent of the order in which errors were raised in a field or in non_field_errors.\n",
        "version": "3.2",
        "FAIL_TO_PASS": [
            "test_eq (test_exceptions.test_validation_error.TestValidationError)",
            "test_eq_nested (test_exceptions.test_validation_error.TestValidationError)",
            "test_hash (test_exceptions.test_validation_error.TestValidationError)",
            "test_hash_nested (test_exceptions.test_validation_error.TestValidationError)"
        ],
        "PASS_TO_PASS": [
            "test_messages_concatenates_error_dict_values (test_exceptions.test_validation_error.TestValidationError)"
        ],
        "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
        "patch": "diff --git a/django/core/exceptions.py b/django/core/exceptions.py\n--- a/django/core/exceptions.py\n+++ b/django/core/exceptions.py\n@@ -1,6 +1,9 @@\n \"\"\"\n Global Django exception and warning classes.\n \"\"\"\n+import operator\n+\n+from django.utils.hashable import make_hashable\n \n \n class FieldDoesNotExist(Exception):\n@@ -182,6 +185,23 @@ def __str__(self):\n     def __repr__(self):\n         return 'ValidationError(%s)' % self\n \n+    def __eq__(self, other):\n+        if not isinstance(other, ValidationError):\n+            return NotImplemented\n+        return hash(self) == hash(other)\n+\n+    def __hash__(self):\n+        # Ignore params and messages ordering.\n+        if hasattr(self, 'message'):\n+            return hash((\n+                self.message,\n+                self.code,\n+                tuple(sorted(make_hashable(self.params))) if self.params else None,\n+            ))\n+        if hasattr(self, 'error_dict'):\n+            return hash(tuple(sorted(make_hashable(self.error_dict))))\n+        return hash(tuple(sorted(self.error_list, key=operator.attrgetter('message'))))\n+\n \n class EmptyResultSet(Exception):\n     \"\"\"A database query predicate is impossible.\"\"\"\n",
        "pr_link": "https://github.com/django/django/pull/13220"
    }
}