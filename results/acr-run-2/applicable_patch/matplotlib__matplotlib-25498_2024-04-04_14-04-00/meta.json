{
    "task_id": "matplotlib__matplotlib-25498",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.7",
        "env_name": "setup_matplotlib__matplotlib__3.7",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "pytest --no-header -rA --tb=no -p no:cacheprovider lib/matplotlib/tests/test_colorbar.py"
    },
    "task_info": {
        "instance_id": "matplotlib__matplotlib-25498",
        "base_commit": "78bf53caacbb5ce0dc7aa73f07a74c99f1ed919b",
        "hints_text": "You have run into a big bug in imshow, not colorbar.  As a workaround, after setting `plot.norm`, call `plot.autoscale()`.  Then the `update_bruteforce` will work.\nWhen the norm is changed, it should pick up the vmax, vmin values from the autoscaling; but this is not happening.  Actually, it's worse than that; it fails even if the norm is set as a kwarg in the call to imshow. I haven't looked beyond that to see why.  I've confirmed the problem with master.\n\nIn ipython using `%matplotlib` setting the norm the first time works, changing it back later to\n`Normalize()` or something other blows up:\n\n```\n--> 199         self.pixels.autoscale()\n    200         self.update(force=True)\n    201 \n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cm.py in autoscale(self)\n    323             raise TypeError('You must first set_array for mappable')\n    324         self.norm.autoscale(self._A)\n--> 325         self.changed()\n    326 \n    327     def autoscale_None(self):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cm.py in changed(self)\n    357         callbackSM listeners to the 'changed' signal\n    358         \"\"\"\n--> 359         self.callbacksSM.process('changed', self)\n    360 \n    361         for key in self.update_dict:\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cbook.py in process(self, s, *args, **kwargs)\n    560             for cid, proxy in list(six.iteritems(self.callbacks[s])):\n    561                 try:\n--> 562                     proxy(*args, **kwargs)\n    563                 except ReferenceError:\n    564                     self._remove_proxy(proxy)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cbook.py in __call__(self, *args, **kwargs)\n    427             mtd = self.func\n    428         # invoke the callable and return the result\n--> 429         return mtd(*args, **kwargs)\n    430 \n    431     def __eq__(self, other):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in on_mappable_changed(self, mappable)\n    915         self.set_cmap(mappable.get_cmap())\n    916         self.set_clim(mappable.get_clim())\n--> 917         self.update_normal(mappable)\n    918 \n    919     def add_lines(self, CS, erase=True):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in update_normal(self, mappable)\n    946         or contour plot to which this colorbar belongs is changed.\n    947         '''\n--> 948         self.draw_all()\n    949         if isinstance(self.mappable, contour.ContourSet):\n    950             CS = self.mappable\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in draw_all(self)\n    346         X, Y = self._mesh()\n    347         C = self._values[:, np.newaxis]\n--> 348         self._config_axes(X, Y)\n    349         if self.filled:\n    350             self._add_solids(X, Y, C)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in _config_axes(self, X, Y)\n    442         ax.add_artist(self.patch)\n    443 \n--> 444         self.update_ticks()\n    445 \n    446     def _set_label(self):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in update_ticks(self)\n    371         \"\"\"\n    372         ax = self.ax\n--> 373         ticks, ticklabels, offset_string = self._ticker()\n    374         if self.orientation == 'vertical':\n    375             ax.yaxis.set_ticks(ticks)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in _ticker(self)\n    592         formatter.set_data_interval(*intv)\n    593 \n--> 594         b = np.array(locator())\n    595         if isinstance(locator, ticker.LogLocator):\n    596             eps = 1e-10\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/ticker.py in __call__(self)\n   1533         'Return the locations of the ticks'\n   1534         vmin, vmax = self.axis.get_view_interval()\n-> 1535         return self.tick_values(vmin, vmax)\n   1536 \n   1537     def tick_values(self, vmin, vmax):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/ticker.py in tick_values(self, vmin, vmax)\n   1551             if vmin <= 0.0 or not np.isfinite(vmin):\n   1552                 raise ValueError(\n-> 1553                     \"Data has no positive values, and therefore can not be \"\n   1554                     \"log-scaled.\")\n   1555 \n\nValueError: Data has no positive values, and therefore can not be log-scaled.\n```\n\nAny news on this? Why does setting the norm back to a linear norm blow up if there are negative values?\n\n``` python\nIn [2]: %matplotlib\nUsing matplotlib backend: Qt4Agg\n\nIn [3]: # %load minimal_norm.py\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import Normalize, LogNorm\n\n\nx, y = np.meshgrid(np.linspace(0, 1, 10), np.linspace(0, 1, 10))\nz = np.random.normal(0, 5, size=x.shape)\n\nfig = plt.figure()\nimg = plt.pcolor(x, y, z, cmap='viridis')\ncbar = plt.colorbar(img)\n   ...: \n\nIn [4]: img.norm = LogNorm()\n\nIn [5]: img.autoscale()\n\nIn [7]: cbar.update_bruteforce(img)\n\nIn [8]: img.norm = Normalize()\n\nIn [9]: img.autoscale()\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-9-e26279d12b00> in <module>()\n----> 1 img.autoscale()\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cm.py in autoscale(self)\n    323             raise TypeError('You must first set_array for mappable')\n    324         self.norm.autoscale(self._A)\n--> 325         self.changed()\n    326 \n    327     def autoscale_None(self):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cm.py in changed(self)\n    357         callbackSM listeners to the 'changed' signal\n    358         \"\"\"\n--> 359         self.callbacksSM.process('changed', self)\n    360 \n    361         for key in self.update_dict:\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cbook.py in process(self, s, *args, **kwargs)\n    561             for cid, proxy in list(six.iteritems(self.callbacks[s])):\n    562                 try:\n--> 563                     proxy(*args, **kwargs)\n    564                 except ReferenceError:\n    565                     self._remove_proxy(proxy)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/cbook.py in __call__(self, *args, **kwargs)\n    428             mtd = self.func\n    429         # invoke the callable and return the result\n--> 430         return mtd(*args, **kwargs)\n    431 \n    432     def __eq__(self, other):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in on_mappable_changed(self, mappable)\n    915         self.set_cmap(mappable.get_cmap())\n    916         self.set_clim(mappable.get_clim())\n--> 917         self.update_normal(mappable)\n    918 \n    919     def add_lines(self, CS, erase=True):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in update_normal(self, mappable)\n    946         or contour plot to which this colorbar belongs is changed.\n    947         '''\n--> 948         self.draw_all()\n    949         if isinstance(self.mappable, contour.ContourSet):\n    950             CS = self.mappable\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in draw_all(self)\n    346         X, Y = self._mesh()\n    347         C = self._values[:, np.newaxis]\n--> 348         self._config_axes(X, Y)\n    349         if self.filled:\n    350             self._add_solids(X, Y, C)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in _config_axes(self, X, Y)\n    442         ax.add_artist(self.patch)\n    443 \n--> 444         self.update_ticks()\n    445 \n    446     def _set_label(self):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in update_ticks(self)\n    371         \"\"\"\n    372         ax = self.ax\n--> 373         ticks, ticklabels, offset_string = self._ticker()\n    374         if self.orientation == 'vertical':\n    375             ax.yaxis.set_ticks(ticks)\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/colorbar.py in _ticker(self)\n    592         formatter.set_data_interval(*intv)\n    593 \n--> 594         b = np.array(locator())\n    595         if isinstance(locator, ticker.LogLocator):\n    596             eps = 1e-10\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/ticker.py in __call__(self)\n   1536         'Return the locations of the ticks'\n   1537         vmin, vmax = self.axis.get_view_interval()\n-> 1538         return self.tick_values(vmin, vmax)\n   1539 \n   1540     def tick_values(self, vmin, vmax):\n\n/home/maxnoe/.local/anaconda3/envs/ctapipe/lib/python3.5/site-packages/matplotlib/ticker.py in tick_values(self, vmin, vmax)\n   1554             if vmin <= 0.0 or not np.isfinite(vmin):\n   1555                 raise ValueError(\n-> 1556                     \"Data has no positive values, and therefore can not be \"\n   1557                     \"log-scaled.\")\n   1558 \n\nValueError: Data has no positive values, and therefore can not be log-scaled\n```\n\nThis issue has been marked \"inactive\" because it has been 365 days since the last comment. If this issue is still present in recent Matplotlib releases, or the feature request is still wanted, please leave a comment and this label will be removed. If there are no updates in another 30 days, this issue will be automatically closed, but you are free to re-open or create a new issue if needed. We value issue reports, and this procedure is meant to help us resurface and prioritize issues that have not been addressed yet, not make them disappear.  Thanks for your help!",
        "created_at": "2023-03-18T17:01:11Z",
        "test_patch": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -657,6 +657,12 @@ def test_colorbar_scale_reset():\n \n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n+    # log scale with no vmin/vmax set should scale to the data if there\n+    # is a mappable already associated with the colorbar, not (0, 1)\n+    pcm.norm = LogNorm()\n+    assert pcm.norm.vmin == z.min()\n+    assert pcm.norm.vmax == z.max()\n+\n \n def test_colorbar_get_ticks_2():\n     plt.rcParams['_internal.classic_mode'] = False\n",
        "repo": "matplotlib/matplotlib",
        "problem_statement": "Update colorbar after changing mappable.norm\nHow can I update a colorbar, after I changed the norm instance of the colorbar?\n\n`colorbar.update_normal(mappable)` has now effect and `colorbar.update_bruteforce(mappable)` throws a `ZeroDivsionError`-Exception.\n\nConsider this example:\n\n``` python\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nimport numpy as np\n\nimg = 10**np.random.normal(1, 1, size=(50, 50))\n\nfig, ax = plt.subplots(1, 1)\nplot = ax.imshow(img, cmap='gray')\ncb = fig.colorbar(plot, ax=ax)\nplot.norm = LogNorm()\ncb.update_normal(plot)  # no effect\ncb.update_bruteforce(plot)  # throws ZeroDivisionError\nplt.show()\n```\n\nOutput for `cb.update_bruteforce(plot)`:\n\n```\nTraceback (most recent call last):\n  File \"test_norm.py\", line 12, in <module>\n    cb.update_bruteforce(plot)\n  File \"/home/maxnoe/.local/anaconda3/lib/python3.4/site-packages/matplotlib/colorbar.py\", line 967, in update_bruteforce\n    self.draw_all()\n  File \"/home/maxnoe/.local/anaconda3/lib/python3.4/site-packages/matplotlib/colorbar.py\", line 342, in draw_all\n    self._process_values()\n  File \"/home/maxnoe/.local/anaconda3/lib/python3.4/site-packages/matplotlib/colorbar.py\", line 664, in _process_values\n    b = self.norm.inverse(self._uniform_y(self.cmap.N + 1))\n  File \"/home/maxnoe/.local/anaconda3/lib/python3.4/site-packages/matplotlib/colors.py\", line 1011, in inverse\n    return vmin * ma.power((vmax / vmin), val)\nZeroDivisionError: division by zero\n```\n\n",
        "version": "3.7",
        "FAIL_TO_PASS": [
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_scale_reset"
        ],
        "PASS_TO_PASS": [
            "lib/matplotlib/tests/test_colorbar.py::test_anchored_cbar_position_using_specgrid",
            "lib/matplotlib/tests/test_colorbar.py::test_aspects",
            "lib/matplotlib/tests/test_colorbar.py::test_axes_handles_same_functions[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_boundaries[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_cbar_minorticks_for_rc_xyminortickvisible",
            "lib/matplotlib/tests/test_colorbar.py::test_centerednorm",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_autoticks",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_autotickslog",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_axes_kw",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_axes_parmeters",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_change_lim_scale[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_closed_patch[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_contourf_extend_patches[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_errors[kwargs0-TypeError-location",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_errors[kwargs1-TypeError-location",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_errors[kwargs2-ValueError-'top'",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_errors[kwargs3-ValueError-invalid",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extend_alpha[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extend_drawedges[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[both-expected2-horizontal]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[both-expected2-vertical]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[max-expected1-horizontal]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[max-expected1-vertical]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[min-expected0-horizontal]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_inverted_axis[min-expected0-vertical]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_length[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_extension_shape[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_format[%4.2e]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_format[{x:.2e}]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_get_ticks",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_get_ticks_2",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_int[clim0]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_int[clim1]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_inverted_ticks",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_label",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_log_minortick_labels",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_lognorm_extension[both]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_lognorm_extension[max]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_lognorm_extension[min]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_minorticks_on_off",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_no_warning_rcparams_grid_true",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_positioning[png-False]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_positioning[png-True]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_powernorm_extension",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_renorm",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_set_formatter_locator",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_single_ax_panchor_east[constrained]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_single_ax_panchor_east[standard]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_single_ax_panchor_false",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_single_scatter[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbar_ticks",
            "lib/matplotlib/tests/test_colorbar.py::test_colorbarbase",
            "lib/matplotlib/tests/test_colorbar.py::test_contour_colorbar[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_gridspec_make_colorbar[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_inset_colorbar_layout",
            "lib/matplotlib/tests/test_colorbar.py::test_keeping_xlabel[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_mappable_2d_alpha",
            "lib/matplotlib/tests/test_colorbar.py::test_mappable_no_alpha",
            "lib/matplotlib/tests/test_colorbar.py::test_negative_boundarynorm",
            "lib/matplotlib/tests/test_colorbar.py::test_offset_text_loc",
            "lib/matplotlib/tests/test_colorbar.py::test_parentless_mappable",
            "lib/matplotlib/tests/test_colorbar.py::test_passing_location[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_proportional_colorbars[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_remove_cb_whose_mappable_has_no_figure[png]",
            "lib/matplotlib/tests/test_colorbar.py::test_remove_from_figure[no",
            "lib/matplotlib/tests/test_colorbar.py::test_remove_from_figure[with",
            "lib/matplotlib/tests/test_colorbar.py::test_remove_from_figure_cl",
            "lib/matplotlib/tests/test_colorbar.py::test_title_text_loc",
            "lib/matplotlib/tests/test_colorbar.py::test_twoslope_colorbar[png]"
        ],
        "environment_setup_commit": "0849036fd992a2dd133a0cffc3f84f58ccf1840f",
        "patch": "diff --git a/lib/matplotlib/colorbar.py b/lib/matplotlib/colorbar.py\n--- a/lib/matplotlib/colorbar.py\n+++ b/lib/matplotlib/colorbar.py\n@@ -301,11 +301,6 @@ def __init__(self, ax, mappable=None, *, cmap=None,\n         if mappable is None:\n             mappable = cm.ScalarMappable(norm=norm, cmap=cmap)\n \n-        # Ensure the given mappable's norm has appropriate vmin and vmax\n-        # set even if mappable.draw has not yet been called.\n-        if mappable.get_array() is not None:\n-            mappable.autoscale_None()\n-\n         self.mappable = mappable\n         cmap = mappable.cmap\n         norm = mappable.norm\n@@ -1101,7 +1096,10 @@ def _process_values(self):\n             b = np.hstack((b, b[-1] + 1))\n \n         # transform from 0-1 to vmin-vmax:\n+        if self.mappable.get_array() is not None:\n+            self.mappable.autoscale_None()\n         if not self.norm.scaled():\n+            # If we still aren't scaled after autoscaling, use 0, 1 as default\n             self.norm.vmin = 0\n             self.norm.vmax = 1\n         self.norm.vmin, self.norm.vmax = mtransforms.nonsingular(\n",
        "pr_link": "https://github.com/matplotlib/matplotlib/pull/25498"
    }
}