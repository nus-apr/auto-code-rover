{
    "task_id": "django__django-16400",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/django__django/setup_django__django__4.2",
        "env_name": "setup_django__django__4.2",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "./tests/runtests.py --verbosity 2 auth_tests.test_management"
    },
    "task_info": {
        "instance_id": "django__django-16400",
        "base_commit": "0bd2c0c9015b53c41394a1c0989afbfd94dc2830",
        "hints_text": "Thanks for this report, it's related with adding missing permissions. I was able to fix this by setting _state.db, however I'm not convinced that it's the best solution: django/contrib/auth/management/__init__.py diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py index 0b5a982617..27fe0df1d7 100644 a b def create_permissions( 9494 ) 9595 .values_list(\"content_type\", \"codename\") 9696 ) 97 98 perms = [ 99 Permission(codename=codename, name=name, content_type=ct) 100 for ct, (codename, name) in searched_perms 101 if (ct.pk, codename) not in all_perms 102 ] 97 perms = [] 98 for ct, (codename, name) in searched_perms: 99 if (ct.pk, codename) not in all_perms: 100 permission = Permission() 101 permission._state.db = using 102 permission.codename = codename 103 permission.name = name 104 permission.content_type = ct 105 perms.append(permission) 103106 Permission.objects.using(using).bulk_create(perms) 104107 if verbosity >= 2: 105108 for perm in perms: Partly related to #29843.\nThis patch resolves the problem at my end. I hope it can be added in the 4.1.4 since #29843 seems to be not actively worked on at the moment.\nAfter diving a bit deeper it turned out that the issue was with one of the libraries in my project which was not adapted for multi-DB. I've made a PR with changes on the django-admin-interface which resolved my issue.\nAryan, this ticket doesn't have submitted PR.\nReplying to Mariusz Felisiak: Thanks for this report, it's related with adding missing permissions. I was able to fix this by setting _state.db, however I'm not convinced that it's the best solution: django/contrib/auth/management/__init__.py diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py index 0b5a982617..27fe0df1d7 100644 a b def create_permissions( 9494 ) 9595 .values_list(\"content_type\", \"codename\") 9696 ) 97 98 perms = [ 99 Permission(codename=codename, name=name, content_type=ct) 100 for ct, (codename, name) in searched_perms 101 if (ct.pk, codename) not in all_perms 102 ] 97 perms = [] 98 for ct, (codename, name) in searched_perms: 99 if (ct.pk, codename) not in all_perms: 100 permission = Permission() 101 permission._state.db = using 102 permission.codename = codename 103 permission.name = name 104 permission.content_type = ct 105 perms.append(permission) 103106 Permission.objects.using(using).bulk_create(perms) 104107 if verbosity >= 2: 105108 for perm in perms: Partly related to #29843. I think bulk_create already sets the _state.db to the value passed in .using(), right? Or is it in bulk_create that we require _state.db to be set earlier? In which case, we could perhaps change something inside of this method. Replying to Vasanth: After diving a bit deeper it turned out that the issue was with one of the libraries in my project which was not adapted for multi-DB. I've made a PR with changes on the django-admin-interface which resolved my issue. So would it be relevant to close the issue or is the bug really related to Django itself?\nReplying to David Wobrock: I think bulk_create already sets the _state.db to the value passed in .using(), right? Yes, but it's a different issue, strictly related with Permission and its content_type. get_content_type() is trying to find a content type using obj._state.db so when we create a Permission() without ._state.db it will first try to find a content type in the default db. So would it be relevant to close the issue or is the bug really related to Django itself? IMO we should fix this for permissions.\nReplying to Mariusz Felisiak: Replying to David Wobrock: I think bulk_create already sets the _state.db to the value passed in .using(), right? Yes, but it's a different issue, strictly related with Permission and its content_type. get_content_type() is trying to find a content type using obj._state.db so when we create a Permission() without ._state.db it will first try to find a content type in the default db. Okay, I understand the issue now, thanks for the details!! First thing, it makes me wonder why we require to have a DB attribute set, at a moment where we are not (yet) interacting with the DB. So we are currently checking, when setting the content_type FK, that the router allows this relation. I guess one option is to not do that for not-saved model instances. Would it make sense to defer this to when we start interacting with the DB? But it brings a whole other lot of changes and challenges, like changing a deep behaviour of FKs and multi-tenancy :/ Apart from that, if we don't want to set directly the internal attribute _state.db, I guess we would need a proper way to pass the db/using to the model instantiation. What would be the most Django-y way? Passing it through the model constructor => this has quite a large impact, as a keyword argument would possibly shadow existing field names: Permission(..., db=using). Quite risky in terms of backward compatibility I guess. Adding a method to Model? Something like: Permission(...).using(db), which could perhaps then be re-used in other places also. (EDIT: which wouldn't work, as the setting the FK happens before setting the DB alias.) What do you think ? :) Or am I missing other solutions?\nApart from that, if we don't want to set directly the internal attribute _state.db, I guess we would need a proper way to pass the db/using to the model instantiation. _state is \u200bdocumented so using it is not so bad. What would be the most Django-y way? Passing it through the model constructor => this has quite a large impact, as a keyword argument would possibly shadow existing field names: Permission(..., db=using). Quite risky in terms of backward compatibility I guess. Adding a method to Model? Something like: Permission(...).using(db), which could perhaps then be re-used in other places also. What do you think ? :) Or am I missing other solutions? Django doesn't support cross-db relationships and users were always responsible for assigning related objects from the same db. I don't think that we should add more logic to do this. The Permission-content_type issue is really an edge case in managing relations, as for me we don't need a generic solution for it.",
        "created_at": "2022-12-23T17:17:00Z",
        "test_patch": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1485,3 +1485,22 @@ def test_permission_with_proxy_content_type_created(self):\n                 codename=codename,\n             ).exists()\n         )\n+\n+\n+class DefaultDBRouter:\n+    \"\"\"Route all writes to default.\"\"\"\n+\n+    def db_for_write(self, model, **hints):\n+        return \"default\"\n+\n+\n+@override_settings(DATABASE_ROUTERS=[DefaultDBRouter()])\n+class CreatePermissionsMultipleDatabasesTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def test_set_permissions_fk_to_using_parameter(self):\n+        Permission.objects.using(\"other\").delete()\n+        with self.assertNumQueries(6, using=\"other\") as captured_queries:\n+            create_permissions(apps.get_app_config(\"auth\"), verbosity=0, using=\"other\")\n+        self.assertIn(\"INSERT INTO\", captured_queries[-1][\"sql\"].upper())\n+        self.assertGreater(Permission.objects.using(\"other\").count(), 0)\n",
        "repo": "django/django",
        "problem_statement": "migrate management command does not respect database parameter when adding Permissions.\nDescription\n\t \n\t\t(last modified by Vasanth)\n\t \nWhen invoking migrate with a database parameter, the migration runs successfully. However, there seems to be a DB read request that runs after the migration. This call does not respect the db param and invokes the db router .\nWhen naming the db as a parameter, all DB calls in the context of the migrate command are expected to use the database specified.\nI came across this as I am currently using a thread-local variable to get the active DB with a custom DB router for a multi-tenant service .\nMinimal example \nSetup the custom middleware and custom DB Router as show below. Then run any DB migration. We see that \"read {}\" is being printed before the exception message.\nIdeally none of this code must be called as the DB was specified during management command.\nfrom threading import local\nfrom django.conf import settings\nlocal_state = local()\nclass InvalidTenantException(Exception):\n\tpass\nclass TenantSubdomainMiddleware:\n\tdef __init__(self, get_response):\n\t\tself.get_response = get_response\n\tdef __call__(self, request):\n\t\t## Get Subdomain\n\t\thost = request.get_host().split(\":\")[0]\n\t\tlocal_state.subdomain = (\n\t\t\t# We assume single level of subdomain : app.service.com \n\t\t\t# HOST_IP : used to for local dev. \n\t\t\thost if host in settings.HOST_IP else host.split(\".\")[0]\n\t\t)\n\t\tresponse = self.get_response(request)\n\t\treturn response\nclass TenantDatabaseRouter:\n\tdef _default_db(self):\n\t\tsubdomain = getattr(local_state, \"subdomain\", None)\n\t\tif subdomain is not None and subdomain in settings.TENANT_MAP:\n\t\t\tdb_name = settings.TENANT_MAP[local_state.subdomain]\n\t\t\treturn db_name\n\t\telse:\n\t\t\traise InvalidTenantException()\n\tdef db_for_read(self, model, **hints):\n\t\tprint(\"read\", hints)\n\t\treturn self._default_db()\n\tdef db_for_write(self, model, **hints):\n\t\tprint(\"write\", hints)\n\t\treturn self._default_db()\n\tdef allow_relation(self, obj1, obj2, **hints):\n\t\treturn None\n\tdef allow_migrate(self, db, app_label, model_name=None, **hints):\n\t\treturn None\n## settings.py\nMIDDLEWARE = [\n\t\"utils.tenant_db_router.TenantSubdomainMiddleware\",\n\t\"django.middleware.security.SecurityMiddleware\",\n\t...\n]\nTENANT_MAP = {\"localhost\":\"default\", \"tenant_1\":\"default\"}\nDATABASE_ROUTERS = [\"utils.tenant_db_router.TenantDatabaseRouter\"]\n",
        "version": "4.2",
        "FAIL_TO_PASS": [
            "test_set_permissions_fk_to_using_parameter (auth_tests.test_management.CreatePermissionsMultipleDatabasesTests)"
        ],
        "PASS_TO_PASS": [
            "#21627 -- Executing the changepassword management command should allow",
            "#24075 - Permissions shouldn't be created or deleted if the ContentType",
            "A CommandError should be raised if the user enters in passwords which",
            "A CommandError should be thrown by handle() if the user enters in",
            "A Custom superuser won't be created when a required field isn't provided",
            "A proxy model's permissions use its own content type rather than the",
            "A superuser can be created when a custom user model is in use",
            "Check the operation of the createsuperuser management command",
            "Creation fails if --username is blank.",
            "Creation fails if the username already exists and a custom user model",
            "Creation fails if the username already exists.",
            "Creation fails if the username fails validation.",
            "Creation should fail if the password fails validation.",
            "Creation should fail if the user enters blank passwords.",
            "Creation should fail if the user enters mismatched passwords.",
            "Executing the changepassword management command should change joe's password",
            "If the command is not called from a TTY, it should be skipped and a",
            "Password validation can be bypassed by entering 'y' at the prompt.",
            "The system username is used if --username isn't provided.",
            "You can pass a stdin object as an option and it should be",
            "`post_migrate` handler ordering isn't guaranteed. Simulate a case",
            "call_command() gets username='janet' and interactive=True.",
            "changepassword --database should operate on the specified DB.",
            "createsuperuser --database should operate on the specified DB.",
            "createsuperuser uses a default username when one isn't provided.",
            "test_actual_implementation (auth_tests.test_management.GetDefaultUsernameTestCase)",
            "test_blank_username_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_createsuperuser_command_suggested_username_with_database_option (auth_tests.test_management.MultiDBCreatesuperuserTestCase)",
            "test_default_permissions (auth_tests.test_management.CreatePermissionsTests)",
            "test_email_in_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_environment_variable_m2m_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_environment_variable_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_existing (auth_tests.test_management.GetDefaultUsernameTestCase)",
            "test_fields_with_fk (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_fk_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_fk_via_option_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_m2m (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_m2m_and_through (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_m2m_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_fields_with_m2m_interactive_blank (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_get_pass (auth_tests.test_management.ChangepasswordManagementCommandTestCase)",
            "test_get_pass_no_input (auth_tests.test_management.ChangepasswordManagementCommandTestCase)",
            "test_i18n (auth_tests.test_management.GetDefaultUsernameTestCase)",
            "test_ignore_environment_variable_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_ignore_environment_variable_non_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_input_not_found (auth_tests.test_management.MockInputTests)",
            "test_keyboard_interrupt (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_no_email_argument (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_non_ascii_verbose_name (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_nonexistent_username (auth_tests.test_management.ChangepasswordManagementCommandTestCase)",
            "test_simple (auth_tests.test_management.GetDefaultUsernameTestCase)",
            "test_swappable_user_username_non_unique (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_usermodel_without_password (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_usermodel_without_password_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_fk (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_fk_environment_variable (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_fk_via_option_interactive (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_password_against_required_fields (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_password_against_required_fields_via_option (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_password_against_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_validate_username (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_verbosity_zero (auth_tests.test_management.CreatesuperuserManagementCommandTestCase)",
            "test_with_database (auth_tests.test_management.GetDefaultUsernameTestCase)"
        ],
        "environment_setup_commit": "0fbdb9784da915fce5dcc1fe82bac9b4785749e5",
        "patch": "diff --git a/django/contrib/auth/management/__init__.py b/django/contrib/auth/management/__init__.py\n--- a/django/contrib/auth/management/__init__.py\n+++ b/django/contrib/auth/management/__init__.py\n@@ -95,11 +95,16 @@ def create_permissions(\n         .values_list(\"content_type\", \"codename\")\n     )\n \n-    perms = [\n-        Permission(codename=codename, name=name, content_type=ct)\n-        for ct, (codename, name) in searched_perms\n-        if (ct.pk, codename) not in all_perms\n-    ]\n+    perms = []\n+    for ct, (codename, name) in searched_perms:\n+        if (ct.pk, codename) not in all_perms:\n+            permission = Permission()\n+            permission._state.db = using\n+            permission.codename = codename\n+            permission.name = name\n+            permission.content_type = ct\n+            perms.append(permission)\n+\n     Permission.objects.using(using).bulk_create(perms)\n     if verbosity >= 2:\n         for perm in perms:\n",
        "pr_link": "https://github.com/django/django/pull/16400"
    }
}