{
    "task_id": "sympy__sympy-18835",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.6",
        "env_name": "setup_sympy__sympy__1.6",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "bin/test -C --verbose sympy/utilities/tests/test_iterables.py"
    },
    "task_info": {
        "instance_id": "sympy__sympy-18835",
        "base_commit": "516fa83e69caf1e68306cfc912a13f36c434d51c",
        "hints_text": "I'm not sure there is a need to handle this case. Users should know not to mutate something while iterating over it.\nWith regards to the above discussion, I believe it would indeed be helpful if modifying a passed list to ``uniq`` raises an error while iterating over it, because it does not immediately follow that ``uniq(f)`` would get updated if ``f`` gets updated, as the user might think something like ``uniq`` stores a copy of ``f``, computes the list of unique elements in it, and returns that list. The user may not know, that yield is being used internally instead of return.\r\n\r\nI have a doubt regarding the implementation of ``uniq``:\r\n[https://github.com/sympy/sympy/blob/5bfe93281866f0841b36a429f4090c04a0e81d21/sympy/utilities/iterables.py#L2109-L2124](url)\r\nHere, if the first argument, ``seq`` in ``uniq`` does not have a ``__getitem__`` method, and a TypeError is raised somehow, then we call the ``uniq`` function again on ``seq`` with the updated ``result``, won't that yield ALL of the elements of ``seq`` again, even those which have already been _yielded_? \r\nSo mainly what I wanted to point out was, that if we're assuming that the given ``seq`` is iterable (which we must, since we pass it on to the ``enumerate`` function), by definition, ``seq`` must have either ``__getitem__`` or ``__iter__``, both of which can be used to iterate over the **remaining elements** if the TypeError is raised. \r\nAlso, I'm unable to understand the role of ``result`` in all of this, kindly explain.\r\n\r\nSo should I work on the error handling bit in this function?",
        "created_at": "2020-03-11T23:39:56Z",
        "test_patch": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -703,6 +703,10 @@ def test_uniq():\n         [([1], 2, 2), (2, [1], 2), (2, 2, [1])]\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n \n \n def test_kbins():\n",
        "repo": "sympy/sympy",
        "problem_statement": "uniq modifies list argument\nWhen you iterate over a dictionary or set and try to modify it while doing so you get an error from Python:\r\n```python\r\n>>> multiset('THISTLE')\r\n{'T': 2, 'H': 1, 'I': 1, 'S': 1, 'L': 1, 'E': 1}\r\n>>> for i in _:\r\n...   _.pop(i)\r\n...\r\n2\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nRuntimeError: dictionary changed size during iteration\r\n```\r\nIt would be good to do the same thing from within `uniq` because the output will silently be wrong if you modify a passed list:\r\n```python\r\n>>> f=list('THISTLE')\r\n>>> for i in uniq(f):\r\n...   f.remove(i)\r\n...   i\r\n...\r\n'T'\r\n'I'\r\n'L'\r\n```\r\nI think this would entail recording the size at the start and then checking the size and raising a similar RuntimeError if the size changes.\n",
        "version": "1.6",
        "FAIL_TO_PASS": [
            "test_uniq"
        ],
        "PASS_TO_PASS": [
            "test__partition",
            "test_bell_perm",
            "test_binary_partitions",
            "test_bracelets",
            "test_cartes",
            "test_common_prefix_suffix",
            "test_connected_components",
            "test_derangements",
            "test_dict_merge",
            "test_filter_symbols",
            "test_flatten",
            "test_generate_oriented_forest",
            "test_group",
            "test_has_dups",
            "test_involutions",
            "test_iproduct",
            "test_is_palindromic",
            "test_kbins",
            "test_minlex",
            "test_multiset_combinations",
            "test_multiset_partitions",
            "test_multiset_permutations",
            "test_necklaces",
            "test_numbered_symbols",
            "test_ordered",
            "test_ordered_partitions",
            "test_partitions",
            "test_postfixes",
            "test_postorder_traversal",
            "test_prefixes",
            "test_reshape",
            "test_rotate",
            "test_rotations",
            "test_runs",
            "test_sift",
            "test_strongly_connected_components",
            "test_subsets",
            "test_take",
            "test_topological_sort",
            "test_unflatten",
            "test_variations"
        ],
        "environment_setup_commit": "28b41c73c12b70d6ad9f6e45109a80649c4456da",
        "patch": "diff --git a/sympy/utilities/iterables.py b/sympy/utilities/iterables.py\n--- a/sympy/utilities/iterables.py\n+++ b/sympy/utilities/iterables.py\n@@ -2088,8 +2088,13 @@ def has_variety(seq):\n def uniq(seq, result=None):\n     \"\"\"\n     Yield unique elements from ``seq`` as an iterator. The second\n-    parameter ``result``  is used internally; it is not necessary to pass\n-    anything for this.\n+    parameter ``result``  is used internally; it is not necessary\n+    to pass anything for this.\n+\n+    Note: changing the sequence during iteration will raise a\n+    RuntimeError if the size of the sequence is known; if you pass\n+    an iterator and advance the iterator you will change the\n+    output of this routine but there will be no warning.\n \n     Examples\n     ========\n@@ -2106,15 +2111,27 @@ def uniq(seq, result=None):\n     >>> list(uniq([[1], [2, 1], [1]]))\n     [[1], [2, 1]]\n     \"\"\"\n+    try:\n+        n = len(seq)\n+    except TypeError:\n+        n = None\n+    def check():\n+        # check that size of seq did not change during iteration;\n+        # if n == None the object won't support size changing, e.g.\n+        # an iterator can't be changed\n+        if n is not None and len(seq) != n:\n+            raise RuntimeError('sequence changed size during iteration')\n     try:\n         seen = set()\n         result = result or []\n         for i, s in enumerate(seq):\n             if not (s in seen or seen.add(s)):\n                 yield s\n+                check()\n     except TypeError:\n         if s not in result:\n             yield s\n+            check()\n             result.append(s)\n         if hasattr(seq, '__getitem__'):\n             for s in uniq(seq[i + 1:], result):\n",
        "pr_link": "https://github.com/sympy/sympy/pull/18835"
    }
}