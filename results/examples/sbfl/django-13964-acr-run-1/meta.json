{
    "task_id": "django__django-13964",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/django__django/setup_django__django__4.0",
        "env_name": "setup_django__django__4.0",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "./tests/runtests.py --verbosity 2 many_to_one.models many_to_one.tests"
    },
    "task_info": {
        "instance_id": "django__django-13964",
        "base_commit": "f39634ff229887bf7790c069d0c411b38494ca38",
        "hints_text": "Thanks for this report. product_id is an empty string in \u200b_prepare_related_fields_for_save() that's why pk from a related object is not used. We could use empty_values: diff --git a/django/db/models/base.py b/django/db/models/base.py index 822aad080d..8e7a8e3ae7 100644 --- a/django/db/models/base.py +++ b/django/db/models/base.py @@ -933,7 +933,7 @@ class Model(metaclass=ModelBase): \"%s() prohibited to prevent data loss due to unsaved \" \"related object '%s'.\" % (operation_name, field.name) ) - elif getattr(self, field.attname) is None: + elif getattr(self, field.attname) in field.empty_values: # Use pk from related object if it has been saved after # an assignment. setattr(self, field.attname, obj.pk) but I'm not sure. Related with #28147.",
        "created_at": "2021-02-02T17:07:43Z",
        "test_patch": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -68,6 +68,10 @@ class Parent(models.Model):\n     bestchild = models.ForeignKey('Child', models.SET_NULL, null=True, related_name='favored_by')\n \n \n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+\n class Child(models.Model):\n     name = models.CharField(max_length=20)\n     parent = models.ForeignKey(Parent, models.CASCADE)\n@@ -77,6 +81,10 @@ class ChildNullableParent(models.Model):\n     parent = models.ForeignKey(Parent, models.CASCADE, null=True)\n \n \n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n+\n+\n class ToFieldChild(models.Model):\n     parent = models.ForeignKey(Parent, models.CASCADE, to_field='name', related_name='to_field_children')\n \ndiff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -7,9 +7,9 @@\n from django.utils.translation import gettext_lazy\n \n from .models import (\n-    Article, Category, Child, ChildNullableParent, City, Country, District,\n-    First, Parent, Record, Relation, Reporter, School, Student, Third,\n-    ToFieldChild,\n+    Article, Category, Child, ChildNullableParent, ChildStringPrimaryKeyParent,\n+    City, Country, District, First, Parent, ParentStringPrimaryKey, Record,\n+    Relation, Reporter, School, Student, Third, ToFieldChild,\n )\n \n \n@@ -549,6 +549,16 @@ def test_save_nullable_fk_after_parent_with_to_field(self):\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n \n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child(self):\n+        parent = ParentStringPrimaryKey()\n+        child = ChildStringPrimaryKeyParent(parent=parent)\n+        child.parent.name = 'jeff'\n+        parent.save()\n+        child.save()\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent, parent)\n+        self.assertEqual(child.parent_id, parent.name)\n+\n     def test_fk_to_bigautofield(self):\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n",
        "repo": "django/django",
        "problem_statement": "Saving parent object after setting on child leads to data loss for parents with non-numeric primary key.\nDescription\n\t \n\t\t(last modified by Charlie DeTar)\n\t \nGiven a model with a foreign key relation to another model that has a non-auto CharField as its primary key:\nclass Product(models.Model):\n\tsku = models.CharField(primary_key=True, max_length=50)\nclass Order(models.Model):\n\tproduct = models.ForeignKey(Product, on_delete=models.CASCADE)\nIf the relation is initialized on the parent with an empty instance that does not yet specify its primary key, and the primary key is subsequently defined, the parent does not \"see\" the primary key's change:\nwith transaction.atomic():\n\torder = Order()\n\torder.product = Product()\n\torder.product.sku = \"foo\"\n\torder.product.save()\n\torder.save()\n\tassert Order.objects.filter(product_id=\"\").exists() # Succeeds, but shouldn't\n\tassert Order.objects.filter(product=order.product).exists() # Fails\nInstead of product_id being populated with product.sku, it is set to emptystring. The foreign key constraint which would enforce the existence of a product with sku=\"\" is deferred until the transaction commits. The transaction does correctly fail on commit with a ForeignKeyViolation due to the non-existence of a product with emptystring as its primary key.\nOn the other hand, if the related unsaved instance is initialized with its primary key before assignment to the parent, it is persisted correctly:\nwith transaction.atomic():\n\torder = Order()\n\torder.product = Product(sku=\"foo\")\n\torder.product.save()\n\torder.save()\n\tassert Order.objects.filter(product=order.product).exists() # succeeds\nCommitting the transaction also succeeds.\nThis may have something to do with how the Order.product_id field is handled at assignment, together with something about handling fetching of auto vs non-auto primary keys from the related instance.\n",
        "version": "4.0",
        "FAIL_TO_PASS": [
            "test_save_fk_after_parent_with_non_numeric_pk_set_on_child (many_to_one.tests.ManyToOneTests)"
        ],
        "PASS_TO_PASS": [
            "Model.save() invalidates stale ForeignKey relations after a primary key",
            "test_add (many_to_one.tests.ManyToOneTests)",
            "test_add_after_prefetch (many_to_one.tests.ManyToOneTests)",
            "test_add_remove_set_by_pk_raises (many_to_one.tests.ManyToOneTests)",
            "test_add_then_remove_after_prefetch (many_to_one.tests.ManyToOneTests)",
            "test_assign (many_to_one.tests.ManyToOneTests)",
            "test_assign_fk_id_none (many_to_one.tests.ManyToOneTests)",
            "test_assign_fk_id_value (many_to_one.tests.ManyToOneTests)",
            "test_cached_foreign_key_with_to_field_not_cleared_by_save (many_to_one.tests.ManyToOneTests)",
            "test_clear_after_prefetch (many_to_one.tests.ManyToOneTests)",
            "test_create (many_to_one.tests.ManyToOneTests)",
            "test_create_relation_with_gettext_lazy (many_to_one.tests.ManyToOneTests)",
            "test_deepcopy_and_circular_references (many_to_one.tests.ManyToOneTests)",
            "test_delete (many_to_one.tests.ManyToOneTests)",
            "test_explicit_fk (many_to_one.tests.ManyToOneTests)",
            "test_fk_assignment_and_related_object_cache (many_to_one.tests.ManyToOneTests)",
            "test_fk_instantiation_outside_model (many_to_one.tests.ManyToOneTests)",
            "test_fk_to_bigautofield (many_to_one.tests.ManyToOneTests)",
            "test_fk_to_smallautofield (many_to_one.tests.ManyToOneTests)",
            "test_get (many_to_one.tests.ManyToOneTests)",
            "test_hasattr_related_object (many_to_one.tests.ManyToOneTests)",
            "test_manager_class_caching (many_to_one.tests.ManyToOneTests)",
            "test_multiple_foreignkeys (many_to_one.tests.ManyToOneTests)",
            "test_related_object (many_to_one.tests.ManyToOneTests)",
            "test_relation_unsaved (many_to_one.tests.ManyToOneTests)",
            "test_remove_after_prefetch (many_to_one.tests.ManyToOneTests)",
            "test_reverse_assignment_deprecation (many_to_one.tests.ManyToOneTests)",
            "test_reverse_foreign_key_instance_to_field_caching (many_to_one.tests.ManyToOneTests)",
            "test_reverse_selects (many_to_one.tests.ManyToOneTests)",
            "test_save_nullable_fk_after_parent (many_to_one.tests.ManyToOneTests)",
            "test_save_nullable_fk_after_parent_with_to_field (many_to_one.tests.ManyToOneTests)",
            "test_select_related (many_to_one.tests.ManyToOneTests)",
            "test_selects (many_to_one.tests.ManyToOneTests)",
            "test_set (many_to_one.tests.ManyToOneTests)",
            "test_set_after_prefetch (many_to_one.tests.ManyToOneTests)",
            "test_values_list_exception (many_to_one.tests.ManyToOneTests)"
        ],
        "environment_setup_commit": "475cffd1d64c690cdad16ede4d5e81985738ceb4",
        "patch": "diff --git a/django/db/models/base.py b/django/db/models/base.py\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -933,7 +933,7 @@ def _prepare_related_fields_for_save(self, operation_name):\n                         \"%s() prohibited to prevent data loss due to unsaved \"\n                         \"related object '%s'.\" % (operation_name, field.name)\n                     )\n-                elif getattr(self, field.attname) is None:\n+                elif getattr(self, field.attname) in field.empty_values:\n                     # Use pk from related object if it has been saved after\n                     # an assignment.\n                     setattr(self, field.attname, obj.pk)\n",
        "pr_link": "https://github.com/django/django/pull/13964"
    }
}