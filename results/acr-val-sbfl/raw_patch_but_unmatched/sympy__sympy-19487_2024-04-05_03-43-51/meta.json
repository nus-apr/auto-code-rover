{
    "task_id": "sympy__sympy-19487",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.7",
        "env_name": "setup_sympy__sympy__1.7",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "bin/test -C --verbose sympy/core/tests/test_subs.py sympy/functions/elementary/tests/test_complexes.py"
    },
    "task_info": {
        "instance_id": "sympy__sympy-19487",
        "base_commit": "25fbcce5b1a4c7e3956e6062930f4a44ce95a632",
        "hints_text": "Getting nan for `sign(0)` would be pretty [non-intuitive](https://en.wikipedia.org/wiki/Sign_function) for any mathematical programmer given it's non-derivative definition.\r\n\r\nIf a rewrite request cannot be fulfilled under all conditions and the request was not for Piecewise, I think the rewrite should return None.\nActually I think it's fine if the rewrite doesn't always work. At least something like this could rewrite:\r\n```julia\r\nIn [2]: sign(1+I).rewrite(Abs)                                                                                                                 \r\nOut[2]: sign(1 + \u2148)\r\n```\nYou can use piecewise like\r\n```\r\nPiecewise(\r\n    (0, Eq(x, 0)),\r\n    (x / Abs(x), Ne(x, 0))\r\n)\r\n```\nOriginally this question comes from SO:\r\nhttps://stackoverflow.com/questions/61676438/integrating-and-deriving-absolute-functions-sympy/61681347#61681347\r\n\r\nThe original question was about `diff(Abs(x))`:\r\n```\r\nIn [2]: x = Symbol('x', real=True)                                                                                                             \r\n\r\nIn [3]: Abs(x).diff(x)                                                                                                                         \r\nOut[3]: sign(x)\r\n```\r\nMaybe the result from `diff` should be a `Piecewise` or at least an `ExprCondPair` guarding against `x=0`.\nThe problem is that real-valued functions like abs, re, im, arg,... are not holomorphic and have no complex derivative. See also https://github.com/sympy/sympy/issues/8502.\n@jksuom could we add conditions in the `Derivative` class of the functions module which would check if the expression is an instance of a non-holomorphic function, in such a case it could raise an error or in the case of `Abs` simply  check the domain. I believe all the classes in `sympy/functions/elementary/complexes.py` could be checked.\nWould it be possible to add an `_eval_derivative` method raising an error to those functions?\nWhen would it raise?\nIf the function is non-holomorphic, there is no derivative to be returned.\nThere is a reasonable derivative of `Abs` when defined over the reals though e.g.:\r\n```julia\r\nIn [1]: x = Symbol('x', real=True)                                                                                                \r\n\r\nIn [2]: Abs(x).diff(x)                                                                                                            \r\nOut[2]: sign(x)\r\n```\nMaybe there should be two functions, one defined on reals and the other on complexes.\n> Would it be possible to add an `_eval_derivative` method raising an error to those functions?\r\n\r\nIn the `Derivative` class in `sympy.function`?\r\n\r\n\r\n\r\n> When would it raise?\r\n\r\nAs suggested, if the function is non-holomorphic or in the case of `Abs()` it could be a check on the domain of the argument.\r\n\r\n\r\n> Maybe there should be two functions, one defined on reals and the other on complexes.\r\n\r\nI am not sure if there are any non-holomorphic functions on Real numbers. In my opinion only the `Abs()` function would fall in this case. Hence I think this could be done using one function only.\n```\r\ndef _eval_derivative(self, expr):\r\n    if isinstance(expr,[re, im, sign, arg, conjugate]):\r\n\traise TypeError(\"Derivative not possible for Non-Holomorphic functions\")\r\n    if isinstance(expr,Abs):\r\n\tif Abs.arg[0].free_symbols.is_complex:\r\n\t    raises TypeError(\"There is a complex argument which makes Abs non-holomorphic\")\r\n```\r\nThis is something I was thinking but I am not sure about it as `Derivative` class already has a method with the same name. I also think that appropriate changes also need to be made in the `fdiff()` method of the `Abs` class.\r\n@jksuom I wanted to know if there are more non-holomorphic functions in sympy/functions/elementary/complexes.py to which an error can be raised.\nThose functions in complexes.py have a `_eval_derivative` method. Maybe that would be the proper place for raising an error if that is desired.\nAre there any other examples of functions that raise when differentiated?\r\n\r\nI just tried\r\n```julia\r\nIn [83]: n = Symbol('n', integer=True, positive=True)                                                                             \r\n\r\nIn [84]: totient(n).diff(n)                                                                                                       \r\nOut[84]: \r\nd             \r\n\u2500\u2500(totient(n))\r\ndn \r\n```\n@oscarbenjamin I am not sure if this is a situation when it should raise, for example: if `n` here is a prime number the derivative wrt `n` would hence be `1` . Although in sympy \r\n```\r\n>>> x = Symbol('x', real=True, prime=True)\r\n>>> totient(x).evalf()\r\n\u03d5(x)\r\n```\r\nis the output and not `x-1`.Maybe this kind of functionality can be added.\r\n@jksuom I think your way is correct and wanted to ask if the error to be raised is appropriately `TypeError`?\nI don't think that the totient function should be differentiable. I was just trying to think of functions where it might be an error to differentiate them.\r\n\r\nI think it's better to leave the derivative of Abs unevaluated. You might have something like `Abs(f(x))` where `f` can be substituted for something reasonable later.\n@dhruvmendiratta6 Yes, I think that `TypeError` would be the appropriate choice. Note, however, that raising errors would probably break some tests. It may be desirable to add some try-except blocks to handle those properly.\nWhat about something like this:\r\n```julia\r\nIn [21]: x = Symbol('x', real=True)                                                                                               \r\n\r\nIn [22]: f = Function('f')                                                                                                        \r\n\r\nIn [23]: e = Derivative(Abs(f(x)), x)                                                                                             \r\n\r\nIn [24]: e                                                                                                                        \r\nOut[24]: \r\nd         \r\n\u2500\u2500(\u2502f(x)\u2502)\r\ndx        \r\n\r\nIn [25]: e.subs(f, cosh)                                                                                                          \r\nOut[25]: \r\nd          \r\n\u2500\u2500(cosh(x))\r\ndx         \r\n\r\nIn [26]: e.subs(f, cosh).doit()                                                                                                   \r\nOut[26]: sinh(x)\r\n```\n@jksuom @oscarbenjamin \r\nAny suggestion on how this can be done?\r\nI think changes need to be made here\r\nhttps://github.com/sympy/sympy/blob/7c11a00d4ace555e8be084d69c4da4e6f4975f64/sympy/functions/elementary/complexes.py#L605-L608\r\nto leave the derivative of `Abs` unevaluated. I tried changing this to \r\n```\r\ndef _eval_derivative(self, x):\r\n        if self.args[0].is_extended_real or self.args[0].is_imaginary:\r\n            return Derivative(self.args[0], x, evaluate=True) \\\r\n                * Derivative(self, x, evaluate=False)\r\n```\r\nwhich gives\r\n```\r\n>>> x = Symbol('x', real = True)\r\n>>> Abs(x**3).diff(x)\r\nx**2*Derivative(Abs(x), x) + 2*x*Abs(x)\r\n```\r\nBut then I can't figure out how to evaluate when the need arises.The above result,which I think is wrong, occurs even when no changes are made.\nI think rewrite in general can't avoid having situations where things are only defined correctly in the limit, unless we return a Piecewise. For example, `sinc(x).rewrite(sin)`.\n```py\r\n>>> pprint(sinc(x).rewrite(sin))\r\n\u23a7sin(x)\r\n\u23aa\u2500\u2500\u2500\u2500\u2500\u2500  for x \u2260 0\r\n\u23a8  x\r\n\u23aa\r\n\u23a9  1     otherwise\r\n```\nI made `_eval_rewrite_as_Abs()` for the `sign` class which gives the following:\r\n```\r\n>>> sign(x).rewrite(Abs)\r\nPiecewise((0, Eq(x, 0)), (x/Abs(x), True))\r\n```\r\nAlthough as discussed earlier raising an error in `_eval_derivative()` causes some tests to break :\r\n```\r\nFile \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 414, in test_Abs\r\n    assert Abs(x).diff(x) == -sign(x)\r\n File \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 833, in test_derivatives_issue_4757\r\n    assert Abs(f(x)).diff(x).subs(f(x), 1 + I*x).doit() == x/sqrt(1 + x**2)\r\n File \"c:\\users\\mendiratta\\sympy\\sympy\\functions\\elementary\\tests\\test_complexes.py\", line 969, in test_issue_15893\r\n    assert eq.doit() == sign(f(x))\r\n```\r\nThe first two are understood but in the third one both `f` and `x` are real and still are caught by the newly raised error which doesn't make sense as I raised a `TypeError` only if the argument is not real.",
        "created_at": "2020-06-04T09:25:34Z",
        "test_patch": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -855,3 +855,10 @@ def test_issue_17823():\n def test_issue_19326():\n     x, y = [i(t) for i in map(Function, 'xy')]\n     assert (x*y).subs({x: 1 + x, y: x}) == (1 + x)*x\n+\n+def test_issue_19558():\n+    e = (7*x*cos(x) - 12*log(x)**3)*(-log(x)**4 + 2*sin(x) + 1)**2/ \\\n+    (2*(x*cos(x) - 2*log(x)**3)*(3*log(x)**4 - 7*sin(x) + 3)**2)\n+\n+    assert e.subs(x, oo) == AccumBounds(-oo, oo)\n+    assert (sin(x) + cos(x)).subs(x, oo) == AccumBounds(-2, 2)\ndiff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -4,7 +4,7 @@\n     pi, Rational, re, S, sign, sin, sqrt, Symbol, symbols, transpose,\n     zoo, exp_polar, Piecewise, Interval, comp, Integral, Matrix,\n     ImmutableMatrix, SparseMatrix, ImmutableSparseMatrix, MatrixSymbol,\n-    FunctionMatrix, Lambda, Derivative)\n+    FunctionMatrix, Lambda, Derivative, Eq)\n from sympy.core.expr import unchanged\n from sympy.core.function import ArgumentIndexError\n from sympy.testing.pytest import XFAIL, raises\n@@ -296,11 +296,14 @@ def test_sign():\n     assert sign(Symbol('x', real=True, zero=False)).is_nonpositive is None\n \n     x, y = Symbol('x', real=True), Symbol('y')\n+    f = Function('f')\n     assert sign(x).rewrite(Piecewise) == \\\n         Piecewise((1, x > 0), (-1, x < 0), (0, True))\n     assert sign(y).rewrite(Piecewise) == sign(y)\n     assert sign(x).rewrite(Heaviside) == 2*Heaviside(x, H0=S(1)/2) - 1\n     assert sign(y).rewrite(Heaviside) == sign(y)\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n \n     # evaluate what can be evaluated\n     assert sign(exp_polar(I*pi)*pi) is S.NegativeOne\n",
        "repo": "sympy/sympy",
        "problem_statement": "Rewrite sign as abs\nIn sympy the `sign` function is defined as\r\n```\r\n    sign(z)  :=  z / Abs(z)\r\n```\r\nfor all complex non-zero `z`. There should be a way to rewrite the sign in terms of `Abs` e.g.:\r\n```\r\n>>> sign(x).rewrite(Abs)                                                                                                                   \r\n x \r\n\u2500\u2500\u2500\r\n\u2502x\u2502\r\n```\r\nI'm not sure how the possibility of `x` being zero should be handled currently we have\r\n```\r\n>>> sign(0)                                                                                                                               \r\n0\r\n>>> 0 / Abs(0)                                                                                                                            \r\nnan\r\n```\r\nMaybe `sign(0)` should be `nan` as well. Otherwise maybe rewrite as Abs would have to be careful about the possibility of the arg being zero (that would make the rewrite fail in most cases).\n",
        "version": "1.7",
        "FAIL_TO_PASS": [
            "test_sign"
        ],
        "PASS_TO_PASS": [
            "test_2arg_hack",
            "test_Abs",
            "test_Abs_properties",
            "test_Abs_real",
            "test_Abs_rewrite",
            "test_Function_subs",
            "test_RootOf_issue_10092",
            "test_Subs_subs",
            "test_abs",
            "test_add",
            "test_adjoint",
            "test_arg",
            "test_arg_rewrite",
            "test_as_real_imag",
            "test_bug",
            "test_conjugate",
            "test_conjugate_transpose",
            "test_deriv_sub_bug3",
            "test_derivative_subs",
            "test_derivative_subs2",
            "test_derivative_subs3",
            "test_derivatives_issue_4757",
            "test_dict_ambigous",
            "test_dict_set",
            "test_division",
            "test_equality_subs1",
            "test_equality_subs2",
            "test_functions_subs",
            "test_im",
            "test_issue_10829",
            "test_issue_11413",
            "test_issue_11746",
            "test_issue_12657",
            "test_issue_13333",
            "test_issue_14216",
            "test_issue_14238",
            "test_issue_15234",
            "test_issue_17823",
            "test_issue_19326",
            "test_issue_2877",
            "test_issue_3206",
            "test_issue_3742",
            "test_issue_4035",
            "test_issue_4680",
            "test_issue_4754_derivative_conjugate",
            "test_issue_5217",
            "test_issue_5261",
            "test_issue_5284",
            "test_issue_5651",
            "test_issue_5910",
            "test_issue_6075",
            "test_issue_6079",
            "test_issue_6158",
            "test_issue_6419_6421",
            "test_issue_6559",
            "test_issue_6923",
            "test_issue_6976",
            "test_issue_8886",
            "test_logexppow",
            "test_mul",
            "test_no_arith_subs_on_floats",
            "test_noncommutative_subs",
            "test_periodic_argument",
            "test_polarify",
            "test_pow_eval_subs_no_cache",
            "test_powers",
            "test_principal_branch",
            "test_re",
            "test_recurse_Application_args",
            "test_simultaneous_subs",
            "test_subbug1",
            "test_subbug2",
            "test_subs",
            "test_subs_AccumBounds",
            "test_subs_Matrix",
            "test_subs_basic_funcs",
            "test_subs_commutative",
            "test_subs_constants",
            "test_subs_dict",
            "test_subs_dict1",
            "test_subs_issue_4009",
            "test_subs_iter",
            "test_subs_mixed",
            "test_subs_noncommutative",
            "test_subs_simple",
            "test_subs_wild",
            "test_transpose",
            "test_trigonometric",
            "test_unpolarify",
            "test_zero_assumptions"
        ],
        "environment_setup_commit": "cffd4e0f86fefd4802349a9f9b19ed70934ea354",
        "patch": "diff --git a/sympy/functions/elementary/complexes.py b/sympy/functions/elementary/complexes.py\n--- a/sympy/functions/elementary/complexes.py\n+++ b/sympy/functions/elementary/complexes.py\n@@ -394,6 +394,9 @@ def _eval_rewrite_as_Heaviside(self, arg, **kwargs):\n         if arg.is_extended_real:\n             return Heaviside(arg, H0=S(1)/2) * 2 - 1\n \n+    def _eval_rewrite_as_Abs(self, arg, **kwargs):\n+        return Piecewise((0, Eq(arg, 0)), (arg / Abs(arg), True))\n+\n     def _eval_simplify(self, **kwargs):\n         return self.func(self.args[0].factor())  # XXX include doit?\n \n",
        "pr_link": "https://github.com/sympy/sympy/pull/19487"
    }
}