{
    "task_id": "django__django-13448",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/django__django/setup_django__django__3.2",
        "env_name": "setup_django__django__3.2",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "./tests/runtests.py --verbosity 2 backends.base.app_unmigrated.__init__ backends.base.app_unmigrated.migrations.0001_initial backends.base.app_unmigrated.migrations.__init__ backends.base.app_unmigrated.models backends.base.test_creation"
    },
    "task_info": {
        "instance_id": "django__django-13448",
        "base_commit": "7b9596b974fb0ad1868b10c8c2174e10b72be403",
        "hints_text": "Thanks for this report, now I see that we need to synchronize all apps when MIGRATE is False, see comment. I've totally missed this when reviewing f5ebdfce5c417f9844e86bccc2f12577064d4bad. We can remove the feature from 3.1 if fix is not trivial.\nMocking settings.MIGRATION_MODULES to None for all apps sounds like an easier fix, see draft below: diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py index 503f7f56fd..3c0338d359 100644 --- a/django/db/backends/base/creation.py +++ b/django/db/backends/base/creation.py @@ -69,6 +69,22 @@ class BaseDatabaseCreation: database=self.connection.alias, run_syncdb=True, ) + else: + try: + old = settings.MIGRATION_MODULES + settings.MIGRATION_MODULES = { + app.label: None + for app in apps.get_app_configs() + } + call_command( + 'migrate', + verbosity=max(verbosity - 1, 0), + interactive=False, + database=self.connection.alias, + run_syncdb=True, + ) + finally: + settings.MIGRATION_MODULES = old # We then serialize the current state of the database into a string # and store it on the connection. This slightly horrific process is so people but I'm not convinced.\nThat seems similar to the solution I've been using for a while: class NoMigrations: \"\"\"Disable migrations for all apps\"\"\" def __getitem__(self, item): return None def __contains__(self, item): return True MIGRATION_MODULES = NoMigrations() (Which I also suggested it as a temporary solution in the original ticket https://code.djangoproject.com/ticket/25388#comment:20) I hadn't actually tried this MIGRATION_MODULES override on this project before. I just did a test run with the override and or some reason I had to add a fixtures = ['myapp/initial_data.json'] line to some of the TestCase classes that worked fine without it before. It seems that these test cases really needed this fixture, but for some reason worked fine when migrations are enabled. Is (test) fixture loading somehow tied to migrations? Anyway, the tests work fine (the same 3 failures) with the MIGRATION_MODULES override, so it seems like it would be a reasonable alternative solution.\nIs (test) fixture loading somehow tied to migrations? I don't think so, you've probably have these data somewhere is migrations.",
        "created_at": "2020-09-22T10:28:46Z",
        "test_patch": "diff --git a/tests/backends/base/app_unmigrated/__init__.py b/tests/backends/base/app_unmigrated/__init__.py\nnew file mode 100644\ndiff --git a/tests/backends/base/app_unmigrated/migrations/0001_initial.py b/tests/backends/base/app_unmigrated/migrations/0001_initial.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/backends/base/app_unmigrated/migrations/0001_initial.py\n@@ -0,0 +1,17 @@\n+from django.db import migrations, models\n+\n+\n+class Migration(migrations.Migration):\n+    initial = True\n+\n+    dependencies = []\n+\n+    operations = [\n+        migrations.CreateModel(\n+            name='Foo',\n+            fields=[\n+                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),\n+                ('name', models.CharField(max_length=255)),\n+            ],\n+        ),\n+    ]\ndiff --git a/tests/backends/base/app_unmigrated/migrations/__init__.py b/tests/backends/base/app_unmigrated/migrations/__init__.py\nnew file mode 100644\ndiff --git a/tests/backends/base/app_unmigrated/models.py b/tests/backends/base/app_unmigrated/models.py\nnew file mode 100644\n--- /dev/null\n+++ b/tests/backends/base/app_unmigrated/models.py\n@@ -0,0 +1,8 @@\n+from django.db import models\n+\n+\n+class Foo(models.Model):\n+    name = models.CharField(max_length=255)\n+\n+    class Meta:\n+        app_label = 'app_unmigrated'\ndiff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -6,6 +6,7 @@\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n from django.test import SimpleTestCase, TransactionTestCase\n+from django.test.utils import override_settings\n \n from ..models import (\n     CircularA, CircularB, Object, ObjectReference, ObjectSelfReference,\n@@ -49,31 +50,57 @@ def test_custom_test_name_with_test_prefix(self):\n         self.assertEqual(signature[3], test_name)\n \n \n+@override_settings(INSTALLED_APPS=['backends.base.app_unmigrated'])\n @mock.patch.object(connection, 'ensure_connection')\n-@mock.patch('django.core.management.commands.migrate.Command.handle', return_value=None)\n+@mock.patch.object(connection, 'prepare_database')\n+@mock.patch('django.db.migrations.recorder.MigrationRecorder.has_table', return_value=False)\n+@mock.patch('django.db.migrations.executor.MigrationExecutor.migrate')\n+@mock.patch('django.core.management.commands.migrate.Command.sync_apps')\n class TestDbCreationTests(SimpleTestCase):\n-    def test_migrate_test_setting_false(self, mocked_migrate, mocked_ensure_connection):\n+    available_apps = ['backends.base.app_unmigrated']\n+\n+    def test_migrate_test_setting_false(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = False\n         creation = test_connection.creation_class(test_connection)\n+        if connection.vendor == 'oracle':\n+            # Don't close connection on Oracle.\n+            creation.connection.close = mock.Mock()\n         old_database_name = test_connection.settings_dict['NAME']\n         try:\n             with mock.patch.object(creation, '_create_test_db'):\n                 creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)\n-            mocked_migrate.assert_not_called()\n+            # Migrations don't run.\n+            mocked_migrate.assert_called()\n+            args, kwargs = mocked_migrate.call_args\n+            self.assertEqual(args, ([],))\n+            self.assertEqual(kwargs['plan'], [])\n+            # App is synced.\n+            mocked_sync_apps.assert_called()\n+            mocked_args, _ = mocked_sync_apps.call_args\n+            self.assertEqual(mocked_args[1], {'app_unmigrated'})\n         finally:\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n \n-    def test_migrate_test_setting_true(self, mocked_migrate, mocked_ensure_connection):\n+    def test_migrate_test_setting_true(self, mocked_sync_apps, mocked_migrate, *mocked_objects):\n         test_connection = get_connection_copy()\n         test_connection.settings_dict['TEST']['MIGRATE'] = True\n         creation = test_connection.creation_class(test_connection)\n+        if connection.vendor == 'oracle':\n+            # Don't close connection on Oracle.\n+            creation.connection.close = mock.Mock()\n         old_database_name = test_connection.settings_dict['NAME']\n         try:\n             with mock.patch.object(creation, '_create_test_db'):\n                 creation.create_test_db(verbosity=0, autoclobber=True, serialize=False)\n-            mocked_migrate.assert_called_once()\n+            # Migrations run.\n+            mocked_migrate.assert_called()\n+            args, kwargs = mocked_migrate.call_args\n+            self.assertEqual(args, ([('app_unmigrated', '0001_initial')],))\n+            self.assertEqual(len(kwargs['plan']), 1)\n+            # App is not synced.\n+            mocked_sync_apps.assert_not_called()\n         finally:\n             with mock.patch.object(creation, '_destroy_test_db'):\n                 creation.destroy_test_db(old_database_name, verbosity=0)\n",
        "repo": "django/django",
        "problem_statement": "Test runner setup_databases crashes with \"TEST\": {\"MIGRATE\": False}.\nDescription\n\t\nI'm trying to upgrade a project from Django 3.0 to Django 3.1 and wanted to try out the new \"TEST\": {\"MIGRATE\": False} database setting.\nSadly I'm running into an issue immediately when running ./manage.py test.\nRemoving the \"TEST\": {\"MIGRATE\": False} line allows the tests to run. So this is not blocking the upgrade for us, but it would be nice if we were able to use the new feature to skip migrations during testing.\nFor reference, this project was recently upgraded from Django 1.4 all the way to 3.0 so there might be some legacy cruft somewhere that triggers this.\nHere's the trackeback. I'll try to debug this some more.\nTraceback (most recent call last):\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/utils.py\", line 84, in _execute\n\treturn self.cursor.execute(sql, params)\npsycopg2.errors.UndefinedTable: relation \"django_admin_log\" does not exist\nLINE 1: ...n_flag\", \"django_admin_log\".\"change_message\" FROM \"django_ad...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ^\nThe above exception was the direct cause of the following exception:\nTraceback (most recent call last):\n File \"/usr/local/lib/python3.6/site-packages/django/db/models/sql/compiler.py\", line 1156, in execute_sql\n\tcursor.execute(sql, params)\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/utils.py\", line 66, in execute\n\treturn self._execute_with_wrappers(sql, params, many=False, executor=self._execute)\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/utils.py\", line 75, in _execute_with_wrappers\n\treturn executor(sql, params, many, context)\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/utils.py\", line 84, in _execute\n\treturn self.cursor.execute(sql, params)\n File \"/usr/local/lib/python3.6/site-packages/django/db/utils.py\", line 90, in __exit__\n\traise dj_exc_value.with_traceback(traceback) from exc_value\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/utils.py\", line 84, in _execute\n\treturn self.cursor.execute(sql, params)\ndjango.db.utils.ProgrammingError: relation \"django_admin_log\" does not exist\nLINE 1: ...n_flag\", \"django_admin_log\".\"change_message\" FROM \"django_ad...\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ^\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n File \"./manage.py\", line 15, in <module>\n\tmain()\n File \"./manage.py\", line 11, in main\n\texecute_from_command_line(sys.argv)\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py\", line 401, in execute_from_command_line\n\tutility.execute()\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/__init__.py\", line 395, in execute\n\tself.fetch_command(subcommand).run_from_argv(self.argv)\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/commands/test.py\", line 23, in run_from_argv\n\tsuper().run_from_argv(argv)\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/base.py\", line 330, in run_from_argv\n\tself.execute(*args, **cmd_options)\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/base.py\", line 371, in execute\n\toutput = self.handle(*args, **options)\n File \"/usr/local/lib/python3.6/site-packages/django/core/management/commands/test.py\", line 53, in handle\n\tfailures = test_runner.run_tests(test_labels)\n File \"/usr/local/lib/python3.6/site-packages/django/test/runner.py\", line 695, in run_tests\n\told_config = self.setup_databases(aliases=databases)\n File \"/usr/local/lib/python3.6/site-packages/django/test/runner.py\", line 616, in setup_databases\n\tself.parallel, **kwargs\n File \"/usr/local/lib/python3.6/site-packages/django/test/utils.py\", line 174, in setup_databases\n\tserialize=connection.settings_dict['TEST'].get('SERIALIZE', True),\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/base/creation.py\", line 78, in create_test_db\n\tself.connection._test_serialized_contents = self.serialize_db_to_string()\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/base/creation.py\", line 121, in serialize_db_to_string\n\tserializers.serialize(\"json\", get_objects(), indent=None, stream=out)\n File \"/usr/local/lib/python3.6/site-packages/django/core/serializers/__init__.py\", line 128, in serialize\n\ts.serialize(queryset, **options)\n File \"/usr/local/lib/python3.6/site-packages/django/core/serializers/base.py\", line 90, in serialize\n\tfor count, obj in enumerate(queryset, start=1):\n File \"/usr/local/lib/python3.6/site-packages/django/db/backends/base/creation.py\", line 118, in get_objects\n\tyield from queryset.iterator()\n File \"/usr/local/lib/python3.6/site-packages/django/db/models/query.py\", line 360, in _iterator\n\tyield from self._iterable_class(self, chunked_fetch=use_chunked_fetch, chunk_size=chunk_size)\n File \"/usr/local/lib/python3.6/site-packages/django/db/models/query.py\", line 53, in __iter__\n\tresults = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n File \"/usr/local/lib/python3.6/site-packages/django/db/models/sql/compiler.py\", line 1159, in execute_sql\n\tcursor.close()\npsycopg2.errors.InvalidCursorName: cursor \"_django_curs_139860821038912_sync_1\" does not exist\n",
        "version": "3.2",
        "FAIL_TO_PASS": [
            "test_migrate_test_setting_false (backends.base.test_creation.TestDbCreationTests)"
        ],
        "PASS_TO_PASS": [
            "test_circular_reference (backends.base.test_creation.TestDeserializeDbFromString)",
            "test_circular_reference_with_natural_key (backends.base.test_creation.TestDeserializeDbFromString)",
            "test_custom_test_name (backends.base.test_creation.TestDbSignatureTests)",
            "test_custom_test_name_with_test_prefix (backends.base.test_creation.TestDbSignatureTests)",
            "test_default_name (backends.base.test_creation.TestDbSignatureTests)",
            "test_migrate_test_setting_true (backends.base.test_creation.TestDbCreationTests)",
            "test_self_reference (backends.base.test_creation.TestDeserializeDbFromString)"
        ],
        "environment_setup_commit": "65dfb06a1ab56c238cc80f5e1c31f61210c4577d",
        "patch": "diff --git a/django/db/backends/base/creation.py b/django/db/backends/base/creation.py\n--- a/django/db/backends/base/creation.py\n+++ b/django/db/backends/base/creation.py\n@@ -58,7 +58,14 @@ def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=\n         settings.DATABASES[self.connection.alias][\"NAME\"] = test_database_name\n         self.connection.settings_dict[\"NAME\"] = test_database_name\n \n-        if self.connection.settings_dict['TEST']['MIGRATE']:\n+        try:\n+            if self.connection.settings_dict['TEST']['MIGRATE'] is False:\n+                # Disable migrations for all apps.\n+                old_migration_modules = settings.MIGRATION_MODULES\n+                settings.MIGRATION_MODULES = {\n+                    app.label: None\n+                    for app in apps.get_app_configs()\n+                }\n             # We report migrate messages at one level lower than that\n             # requested. This ensures we don't get flooded with messages during\n             # testing (unless you really ask to be flooded).\n@@ -69,6 +76,9 @@ def create_test_db(self, verbosity=1, autoclobber=False, serialize=True, keepdb=\n                 database=self.connection.alias,\n                 run_syncdb=True,\n             )\n+        finally:\n+            if self.connection.settings_dict['TEST']['MIGRATE'] is False:\n+                settings.MIGRATION_MODULES = old_migration_modules\n \n         # We then serialize the current state of the database into a string\n         # and store it on the connection. This slightly horrific process is so people\n",
        "pr_link": "https://github.com/django/django/pull/13448"
    }
}