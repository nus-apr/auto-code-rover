{
    "task_id": "sympy__sympy-21379",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.9",
        "env_name": "setup_sympy__sympy__1.9",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "bin/test -C --verbose sympy/core/tests/test_arit.py"
    },
    "task_info": {
        "instance_id": "sympy__sympy-21379",
        "base_commit": "624217179aaf8d094e6ff75b7493ad1ee47599b0",
        "hints_text": "Some functions call `Mod` when evaluated. That does not work well with arguments involving `Piecewise` expressions. In particular, calling `gcd` will lead to `PolynomialError`. That error should be caught by something like this:\r\n```\r\n--- a/sympy/core/mod.py\r\n+++ b/sympy/core/mod.py\r\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\r\n         from sympy.core.mul import Mul\r\n         from sympy.core.singleton import S\r\n         from sympy.core.exprtools import gcd_terms\r\n+        from sympy.polys.polyerrors import PolynomialError\r\n         from sympy.polys.polytools import gcd\r\n \r\n         def doit(p, q):\r\n@@ -166,10 +167,13 @@ def doit(p, q):\r\n         # XXX other possibilities?\r\n \r\n         # extract gcd; any further simplification should be done by the user\r\n-        G = gcd(p, q)\r\n-        if G != 1:\r\n-            p, q = [\r\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\r\n+        try:\r\n+            G = gcd(p, q)\r\n+            if G != 1:\r\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\r\n+                        for i in (p, q)]\r\n+        except PolynomialError:\r\n+            G = S.One\r\n         pwas, qwas = p, q\r\n \r\n         # simplify terms\r\n```\nI can't seem to reproduce the OP problem. One suggestion for debugging is to disable the cache e.g. `SYMPY_USE_CACHE=no` but if that makes the problem go away then I guess it's to do with caching somehow and I'm not sure how to debug...\r\n\r\nI can see what @jksuom is referring to:\r\n```python\r\nIn [2]: (Piecewise((x, y > x), (y, True)) / z) % 1\r\n---------------------------------------------------------------------------\r\nPolynomialError\r\n```\r\nThat should be fixed.\r\n\r\nAs an aside you might prefer to use `nfloat` rather than `expr.subs({1:1.0})`:\r\nhttps://docs.sympy.org/latest/modules/core.html#sympy.core.function.nfloat\n@oscarbenjamin My apologies - I missed a line in the post recreating the expression with real x/y/z. Here is the minimum code to reproduce (may require running w/o cache):\r\n```python\r\nfrom sympy import *\r\n\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nYour code minimally identifies the real problem, however. Thanks for pointing out `nfloat`, but this also induces the exact same error.\r\n\r\n\r\n@jksuom I can confirm that your patch fixes the issue on my end! I can put in a PR, and add the minimal test given by @oscarbenjamin, if you would like\nOkay I can reproduce it now.\r\n\r\nThe PR would be good thanks.\r\n\r\nI think that we also need to figure out what the caching issue is though. The error should be deterministic.\r\n\r\nI was suggesting `nfloat` not to fix this issue but because it's possibly a better way of doing what you suggested. I expect that tensorflow is more efficient with integer exponents than float exponents.\nThis is the full traceback:\r\n```python\r\nTraceback (most recent call last):\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 454, in getit\r\n    return self._assumptions[fact]\r\nKeyError: 'zero'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"y.py\", line 5, in <module>\r\n    expr.subs({1: 1.0})\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 949, in subs\r\n    rv = rv._subs(old, new, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 1063, in _subs\r\n    rv = fallback(self, old, new)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/basic.py\", line 1040, in fallback\r\n    rv = self.func(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 473, in __new__\r\n    result = super().__new__(cls, *args, **options)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 285, in __new__\r\n    evaluated = cls.eval(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/functions/elementary/exponential.py\", line 369, in eval\r\n    if arg.is_zero:\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 458, in getit\r\n    return _ask(fact, self)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 513, in _ask\r\n    _ask(pk, obj)\r\n  [Previous line repeated 2 more times]\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/assumptions.py\", line 501, in _ask\r\n    a = evaluate(obj)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/functions/elementary/hyperbolic.py\", line 251, in _eval_is_real\r\n    return (im%pi).is_zero\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/decorators.py\", line 266, in _func\r\n    return func(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/decorators.py\", line 136, in binary_op_wrapper\r\n    return func(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/expr.py\", line 280, in __mod__\r\n    return Mod(self, other)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 473, in __new__\r\n    result = super().__new__(cls, *args, **options)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/cache.py\", line 72, in wrapper\r\n    retval = cfunc(*args, **kwargs)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/function.py\", line 285, in __new__\r\n    evaluated = cls.eval(*args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/core/mod.py\", line 169, in eval\r\n    G = gcd(p, q)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 5306, in gcd\r\n    (F, G), opt = parallel_poly_from_expr((f, g), *gens, **args)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 4340, in parallel_poly_from_expr\r\n    return _parallel_poly_from_expr(exprs, opt)\r\n  File \"/Users/enojb/current/sympy/sympy/sympy/polys/polytools.py\", line 4399, in _parallel_poly_from_expr\r\n    raise PolynomialError(\"Piecewise generators do not make sense\")\r\nsympy.polys.polyerrors.PolynomialError: Piecewise generators do not make sense\r\n```\r\nThe issue arises during a query in the old assumptions. The exponential function checks if its argument is zero here:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/functions/elementary/exponential.py#L369\r\nThat gives:\r\n```python\r\nIn [1]: x, y, z = symbols('x y z', real=True)\r\n\r\nIn [2]: sinh(Piecewise((x, y > x), (y, True)) * z**-1.0).is_zero\r\n---------------------------------------------------------------------------\r\nKeyError\r\n```\r\nBefore processing the assumptions query the value of the queried assumption is stored as `None` here:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/core/assumptions.py#L491-L493\r\nThat `None` remains there if an exception is raised during the query:\r\n```python\r\nIn [1]: x, y, z = symbols('x y z', real=True)\r\n\r\nIn [2]: S = sinh(Piecewise((x, y > x), (y, True)) * z**-1.0)\r\n\r\nIn [3]: S._assumptions\r\nOut[3]: {}\r\n\r\nIn [4]: try:\r\n   ...:     S.is_zero\r\n   ...: except Exception as e:\r\n   ...:     print(e)\r\n   ...: \r\nPiecewise generators do not make sense\r\n\r\nIn [5]: S._assumptions\r\nOut[5]: \r\n{'zero': None,\r\n 'extended_positive': None,\r\n 'extended_real': None,\r\n 'negative': None,\r\n 'commutative': True,\r\n 'extended_negative': None,\r\n 'positive': None,\r\n 'real': None}\r\n```\r\nA subsequent call to create the same expression returns the same object due to the cache and the object still has `None` is its assumptions dict:\r\n```python\r\nIn [6]: S2 = sinh(Piecewise((x, y > x), (y, True)) * z**-1.0)\r\n\r\nIn [7]: S2 is S\r\nOut[7]: True\r\n\r\nIn [8]: S2._assumptions\r\nOut[8]: \r\n{'zero': None,\r\n 'extended_positive': None,\r\n 'extended_real': None,\r\n 'negative': None,\r\n 'commutative': True,\r\n 'extended_negative': None,\r\n 'positive': None,\r\n 'real': None}\r\n\r\nIn [9]: S2.is_zero\r\n\r\nIn [10]: exp(sinh(Piecewise((x, y > x), (y, True)) * z**-1.0))\r\nOut[10]: \r\n     \u239b -1.0 \u239b\u23a7x  for x < y\u239e\u239e\r\n sinh\u239cz    \u22c5\u239c\u23a8            \u239f\u239f\r\n     \u239d      \u239d\u23a9y  otherwise\u23a0\u23a0\r\n\u212f  \r\n```\r\nSubsequent `is_zero` checks just return `None` from the assumptions dict without calling the handlers so they pass without raising.\r\n\r\nThe reason the `is_zero` handler raises first time around is due to the `sinh.is_real` handler which does this:\r\nhttps://github.com/sympy/sympy/blob/624217179aaf8d094e6ff75b7493ad1ee47599b0/sympy/functions/elementary/hyperbolic.py#L250-L251\r\nThe `%` leads to `Mod` with the Piecewise which calls `gcd` as @jksuom showed above.\r\n\r\nThere are a few separate issues here:\r\n\r\n1. The old assumptions system stores `None` when running a query but doesn't remove that `None` when an exception is raised.\r\n2. `Mod` calls `gcd` on the argument when it is a Piecewise and `gcd` without catching the possible exception..\r\n3. The `gcd` function raises an exception when given a `Piecewise`.\r\n\r\nThe fix suggested by @jksuom is for 2. which seems reasonable and I think we can merge a PR for that to fix using `Piecewise` with `Mod`.\r\n\r\nI wonder about 3. as well though. Should `gcd` with a `Piecewise` raise an exception? If so then maybe `Mod` shouldn't be calling `gcd` at all. Perhaps just something like `gcd_terms` or `factor_terms` should be used there.\r\n\r\nFor point 1. I think that really the best solution is not putting `None` into the assumptions dict at all as there are other ways that it can lead to non-deterministic behaviour. Removing that line leads to a lot of different examples of RecursionError though (personally I consider each of those to be a bug in the old assumptions system).\nI'll put a PR together. And, ah I see, yes you are right - good point (regarding TF float exponents).\r\n\r\nI cannot comment on 1 as I'm not really familiar with the assumptions systems. But, regarding 3, would this exception make more sense as a `NotImplementedError` in `gcd`? Consider the potential behavior where `gcd` is applied to each condition of a `Piecewise` expression:\r\n\r\n```python\r\nIn [1]: expr = Piecewise((x, x > 2), (2, True))\r\n\r\nIn [2]: expr\r\nOut[2]: \r\n\u23a7x  for x > 2\r\n\u23a8            \r\n\u23a92  otherwise\r\n\r\nIn [3]: gcd(x, x)\r\nOut[3]: x\r\n\r\nIn [4]: gcd(2, x)\r\nOut[4]: 1\r\n\r\nIn [5]: gcd(expr, x)  # current behavior\r\nPolynomialError: Piecewise generators do not make sense\r\n\r\nIn [6]: gcd(expr, x)  # potential new behavior?\r\nOut[6]: \r\n\u23a7x  for x > 2\r\n\u23a8            \r\n\u23a91  otherwise\r\n```\r\n\r\nThat would be what I expect from `gcd` here. For the `gcd` of two `Piecewise` expressions, this gets messier and I think would involve intersecting sets of conditions.",
        "created_at": "2021-04-24T19:49:52Z",
        "test_patch": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1913,6 +1913,16 @@ def test_Mod():\n     assert Mod(x, y).rewrite(floor) == x - y*floor(x/y)\n     assert ((x - Mod(x, y))/y).rewrite(floor) == floor(x/y)\n \n+    # issue 21373\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    (Piecewise((x_r, y_r > x_r), (y_r, True)) / z) % 1\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    expr.subs({1: 1.0})\n+    sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero\n+\n \n def test_Mod_Pow():\n     # modular exponentiation\n",
        "repo": "sympy/sympy",
        "problem_statement": "Unexpected `PolynomialError` when using simple `subs()` for particular expressions\nI am seeing weird behavior with `subs` for particular expressions with hyperbolic sinusoids with piecewise arguments. When applying `subs`, I obtain an unexpected `PolynomialError`. For context, I was umbrella-applying a casting from int to float of all int atoms for a bunch of random expressions before using a tensorflow lambdify to avoid potential tensorflow type errors. You can pretend the expression below has a `+ 1` at the end, but below is the MWE that I could produce.\r\n\r\nSee the expression below, and the conditions in which the exception arises.\r\n\r\nSympy version: 1.8.dev\r\n\r\n```python\r\nfrom sympy import *\r\nfrom sympy.core.cache import clear_cache\r\n\r\nx, y, z = symbols('x y z')\r\n\r\nclear_cache()\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This works fine\r\nexpr.subs({1: 1.0})\r\n\r\nclear_cache()\r\nx, y, z = symbols('x y z', real=True)\r\nexpr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\r\n# This fails with \"PolynomialError: Piecewise generators do not make sense\"\r\nexpr.subs({1: 1.0})  # error\r\n# Now run it again (isympy...) w/o clearing cache and everything works as expected without error\r\nexpr.subs({1: 1.0})\r\n```\r\n\r\nI am not really sure where the issue is, but I think it has something to do with the order of assumptions in this specific type of expression. Here is what I found-\r\n\r\n- The error only (AFAIK) happens with `cosh` or `tanh` in place of `sinh`, otherwise it succeeds\r\n- The error goes away if removing the division by `z`\r\n- The error goes away if removing `exp` (but stays for most unary functions, `sin`, `log`, etc.)\r\n- The error only happens with real symbols for `x` and `y` (`z` does not have to be real)\r\n\r\nNot too sure how to debug this one.\n",
        "version": "1.9",
        "FAIL_TO_PASS": [
            "test_Mod"
        ],
        "PASS_TO_PASS": [
            "test_Add_Mul_Expr_args",
            "test_Add_Mul_is_finite",
            "test_Add_Mul_is_integer",
            "test_Add_as_coeff_mul",
            "test_Add_as_content_primitive",
            "test_Add_is_comparable",
            "test_Add_is_even_odd",
            "test_Add_is_irrational",
            "test_Add_is_negative_positive",
            "test_Add_is_nonpositive_nonnegative",
            "test_Add_is_positive_2",
            "test_Add_is_rational",
            "test_Add_is_zero",
            "test_AssocOp_doit",
            "test_Mod_Pow",
            "test_Mod_is_integer",
            "test_Mod_is_nonposneg",
            "test_Mul_as_content_primitive",
            "test_Mul_does_not_cancel_infinities",
            "test_Mul_does_not_distribute_infinity",
            "test_Mul_doesnt_expand_exp",
            "test_Mul_hermitian_antihermitian",
            "test_Mul_is_comparable",
            "test_Mul_is_even_odd",
            "test_Mul_is_imaginary_real",
            "test_Mul_is_integer",
            "test_Mul_is_irrational",
            "test_Mul_is_negative_positive",
            "test_Mul_is_negative_positive_2",
            "test_Mul_is_nonpositive_nonnegative",
            "test_Mul_is_rational",
            "test_Mul_with_zero_infinite",
            "test_Pow_as_coeff_mul_doesnt_expand",
            "test_Pow_as_content_primitive",
            "test_Pow_is_comparable",
            "test_Pow_is_even_odd",
            "test_Pow_is_finite",
            "test_Pow_is_integer",
            "test_Pow_is_negative_positive",
            "test_Pow_is_nonpositive_nonnegative",
            "test_Pow_is_real",
            "test_Pow_is_zero",
            "test_Rational_as_content_primitive",
            "test_Symbol",
            "test__neg__",
            "test_add_flatten",
            "test_arit0",
            "test_bug1",
            "test_bug3",
            "test_denest_add_mul",
            "test_div",
            "test_divmod",
            "test_evenness_in_ternary_integer_product_with_even",
            "test_float_int_round",
            "test_issue_14392",
            "test_issue_17130",
            "test_issue_18507",
            "test_issue_3514_18626",
            "test_issue_3531",
            "test_issue_3531b",
            "test_issue_5126",
            "test_issue_5160_6087_6089_6090",
            "test_issue_5460",
            "test_issue_5919",
            "test_issue_6001",
            "test_issue_6040",
            "test_issue_6077",
            "test_issue_6082",
            "test_issue_6611a",
            "test_issue_8247_8354",
            "test_make_args",
            "test_mod_pow",
            "test_mul_add_identity",
            "test_mul_coeff",
            "test_mul_flatten_oo",
            "test_mul_zero_detection",
            "test_ncmul",
            "test_ncpow",
            "test_oddness_in_ternary_integer_product_with_even",
            "test_polar",
            "test_pow",
            "test_pow2",
            "test_pow3",
            "test_pow_E",
            "test_pow_im",
            "test_pow_issue_3516",
            "test_powerbug",
            "test_product_irrational",
            "test_real_Pow",
            "test_real_mul",
            "test_suppressed_evaluation"
        ],
        "environment_setup_commit": "f9a6f50ec0c74d935c50a6e9c9b2cb0469570d91",
        "patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -40,6 +40,7 @@ def eval(cls, p, q):\n         from sympy.core.mul import Mul\n         from sympy.core.singleton import S\n         from sympy.core.exprtools import gcd_terms\n+        from sympy.polys.polyerrors import PolynomialError\n         from sympy.polys.polytools import gcd\n \n         def doit(p, q):\n@@ -166,10 +167,13 @@ def doit(p, q):\n         # XXX other possibilities?\n \n         # extract gcd; any further simplification should be done by the user\n-        G = gcd(p, q)\n-        if G != 1:\n-            p, q = [\n-                gcd_terms(i/G, clear=False, fraction=False) for i in (p, q)]\n+        try:\n+            G = gcd(p, q)\n+            if G != 1:\n+                p, q = [gcd_terms(i/G, clear=False, fraction=False)\n+                        for i in (p, q)]\n+        except PolynomialError:  # issue 21373\n+            G = S.One\n         pwas, qwas = p, q\n \n         # simplify terms\n",
        "pr_link": "https://github.com/sympy/sympy/pull/21379"
    }
}