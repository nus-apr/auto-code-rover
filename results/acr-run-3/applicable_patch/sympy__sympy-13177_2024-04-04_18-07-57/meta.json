{
    "task_id": "sympy__sympy-13177",
    "setup_info": {
        "repo_path": "/media/media0/yuntong/SWE-bench/testbed/sympy__sympy/setup_sympy__sympy__1.1",
        "env_name": "setup_sympy__sympy__1.1",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "bin/test -C --verbose sympy/core/tests/test_numbers.py"
    },
    "task_info": {
        "instance_id": "sympy__sympy-13177",
        "base_commit": "662cfb818e865f580e18b59efbb3540c34232beb",
        "hints_text": "Even if `p.base` is an integer, the exponent must also be positive.\r\n\r\n```\r\nif (p == q or p == -q or p.is_integer and q == 1 or\r\n        p.base == q and q.is_integer and p.is_Pow and p.exp.is_Integer\r\n        and p.exp.is_positive):\r\n    return S.Zero\r\n```\r\n\r\nbecause\r\n\r\n```\r\n>>> 2**-2 % S(2)\r\n1/4\r\n```\nI would like to work on this. \nOne would need just a slight change in the order of the properties, \r\n\r\n\r\n            p.is_Pow and p.base == q and q.is_integer and p.exp.is_Integer\r\n            and p.exp.is_positive):\r\n            return S.Zero\r\n\r\ninstead of\r\n\r\n        p.base == q and q.is_integer and p.is_Pow and p.exp.is_Integer\r\n        and p.exp.is_positive):\r\n        return S.Zero\r\n\r\n\r\notherwise one gets an Attribute error:'Symbol' object has no attribute 'base' from\r\n>>> Mod(x**2, x).\r\n",
        "created_at": "2017-08-22T20:28:20Z",
        "test_patch": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -8,6 +8,7 @@\n from sympy.core.logic import fuzzy_not\n from sympy.core.numbers import (igcd, ilcm, igcdex, seterr, _intcache,\n     igcd2, igcd_lehmer, mpf_norm, comp, mod_inverse)\n+from sympy.core.mod import Mod\n from sympy.utilities.decorator import conserve_mpmath_dps\n from sympy.utilities.iterables import permutations\n from sympy.utilities.pytest import XFAIL, raises\n@@ -121,6 +122,20 @@ def test_mod():\n     assert Integer(10) % 4 == Integer(2)\n     assert 15 % Integer(4) == Integer(3)\n \n+    h = Symbol('h')\n+    m = h ** 2 % h\n+    k = h ** -2 % h\n+    l = Symbol('l', integer=True)\n+    p = Symbol('p', integer=True, positive=True)\n+    q = Symbol('q', integer=True, negative=True)\n+\n+    assert m == h * (h % 1)\n+    assert k == Mod(h ** -2, h, evaluate=False)\n+    assert Mod(l ** p, l) == 0\n+    assert Mod(l ** 2, l) == 0\n+    assert (l ** q % l) == Mod(l ** q, l, evaluate=False)\n+    assert (l ** -2 % l) == Mod(l ** -2, l, evaluate=False)\n+\n \n def test_divmod():\n     assert divmod(S(12), S(8)) == Tuple(1, 4)\n",
        "repo": "sympy/sympy",
        "problem_statement": "Mod(x**2, x) is not (always) 0\nWhen the base is not an integer, `x**2 % x` is not 0. The base is not tested to be an integer in Mod's eval logic:\r\n\r\n```\r\nif (p == q or p == -q or\r\n        p.is_Pow and p.exp.is_Integer and p.base == q or\r\n        p.is_integer and q == 1):\r\n    return S.Zero\r\n```\r\n\r\nso\r\n\r\n```\r\n>>> Mod(x**2, x)\r\n0\r\n```\r\nbut\r\n```\r\n>>> x = S(1.5)\r\n>>> Mod(x**2, x)\r\n0.75\r\n```\n",
        "version": "1.1",
        "FAIL_TO_PASS": [
            "test_mod",
            "test_mod_inverse"
        ],
        "PASS_TO_PASS": [
            "test_Catalan_EulerGamma_prec",
            "test_Div_By_Zero",
            "test_Float",
            "test_Float_RealElement",
            "test_Float_default_to_highprec_from_str",
            "test_Float_eq",
            "test_Float_eval",
            "test_Float_gcd_lcm_cofactors",
            "test_Float_idempotence",
            "test_Float_issue_2107",
            "test_GoldenRatio_expand",
            "test_Infinity",
            "test_Infinity_2",
            "test_Infinity_inequations",
            "test_IntegerInteger",
            "test_Integer_as_index",
            "test_Integer_factors",
            "test_Integer_new",
            "test_Mul_Infinity_Zero",
            "test_NaN",
            "test_Number_new",
            "test_Rational_cmp",
            "test_Rational_factors",
            "test_Rational_gcd_lcm_cofactors",
            "test_Rational_int",
            "test_Rational_new",
            "test_abs1",
            "test_accept_int",
            "test_as_content_primitive",
            "test_bug_sqrt",
            "test_comp",
            "test_comparisons_with_unknown_type",
            "test_conversion_to_mpmath",
            "test_divmod",
            "test_dont_accept_str",
            "test_float_mpf",
            "test_golden_ratio_rewrite_as_sqrt",
            "test_hashing_sympy_integers",
            "test_igcd",
            "test_igcd2",
            "test_igcd_lehmer",
            "test_igcdex",
            "test_ilcm",
            "test_int",
            "test_int_NumberSymbols",
            "test_integer_nthroot_overflow",
            "test_integers_cache",
            "test_invert_numbers",
            "test_isqrt",
            "test_issue_10020",
            "test_issue_10063",
            "test_issue_3321",
            "test_issue_3423",
            "test_issue_3449",
            "test_issue_3692",
            "test_issue_4107",
            "test_issue_4122",
            "test_issue_4172",
            "test_issue_4611",
            "test_issue_6349",
            "test_issue_6640",
            "test_issue_7742",
            "test_issue_9491",
            "test_latex",
            "test_long",
            "test_mpf_norm",
            "test_no_len",
            "test_pi_Pi",
            "test_powers",
            "test_powers_Float",
            "test_powers_Integer",
            "test_powers_Rational",
            "test_real_bug",
            "test_relational",
            "test_seterr",
            "test_special_numbers",
            "test_zoo"
        ],
        "environment_setup_commit": "ec9e3c0436fbff934fa84e22bf07f1b3ef5bfac3",
        "patch": "diff --git a/sympy/core/mod.py b/sympy/core/mod.py\n--- a/sympy/core/mod.py\n+++ b/sympy/core/mod.py\n@@ -39,7 +39,8 @@ def doit(p, q):\n             if p.is_infinite or q.is_infinite or p is nan or q is nan:\n                 return nan\n             if (p == q or p == -q or\n-                    p.is_Pow and p.exp.is_Integer and p.base == q or\n+                    p.is_Pow and p.exp.is_integer and p.base == q and q.is_integer\n+                    and p.exp.is_positive or\n                     p.is_integer and q == 1):\n                 return S.Zero\n \n",
        "pr_link": "https://github.com/sympy/sympy/pull/13177"
    }
}