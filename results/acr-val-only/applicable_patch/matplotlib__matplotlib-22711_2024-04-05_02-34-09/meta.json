{
    "task_id": "matplotlib__matplotlib-22711",
    "setup_info": {
        "repo_path": "/home/haifeng/projects/reverse-prompt/SWE-bench/testbed/matplotlib__matplotlib/setup_matplotlib__matplotlib__3.5",
        "env_name": "setup_matplotlib__matplotlib__3.5",
        "pre_install": [],
        "install": "python -m pip install -e .",
        "test_cmd": "pytest --no-header -rA --tb=no -p no:cacheprovider lib/matplotlib/tests/test_widgets.py"
    },
    "task_info": {
        "instance_id": "matplotlib__matplotlib-22711",
        "base_commit": "f670fe78795b18eb1118707721852209cd77ad51",
        "hints_text": "Huh, the polygon object must have changed inadvertently. Usually, you have\nto \"close\" the polygon by repeating the first vertex, but we make it\npossible for polygons to auto-close themselves. I wonder how (when?) this\nbroke?\n\nOn Tue, Mar 22, 2022 at 10:29 PM vpicouet ***@***.***> wrote:\n\n> Bug summary\n>\n> I think xy[4] = .25, val[0] should be commented in /matplotlib/widgets.\n> py\", line 915, in set_val\n> as it prevents to initialized value for RangeSlider\n> Code for reproduction\n>\n> import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.widgets import RangeSlider\n> # generate a fake imagenp.random.seed(19680801)N = 128img = np.random.randn(N, N)\n> fig, axs = plt.subplots(1, 2, figsize=(10, 5))fig.subplots_adjust(bottom=0.25)\n> im = axs[0].imshow(img)axs[1].hist(img.flatten(), bins='auto')axs[1].set_title('Histogram of pixel intensities')\n> # Create the RangeSliderslider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03])slider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max(),valinit=[0.0,0.0])\n> # Create the Vertical lines on the histogramlower_limit_line = axs[1].axvline(slider.val[0], color='k')upper_limit_line = axs[1].axvline(slider.val[1], color='k')\n>\n> def update(val):\n>     # The val passed to a callback by the RangeSlider will\n>     # be a tuple of (min, max)\n>\n>     # Update the image's colormap\n>     im.norm.vmin = val[0]\n>     im.norm.vmax = val[1]\n>\n>     # Update the position of the vertical lines\n>     lower_limit_line.set_xdata([val[0], val[0]])\n>     upper_limit_line.set_xdata([val[1], val[1]])\n>\n>     # Redraw the figure to ensure it updates\n>     fig.canvas.draw_idle()\n>\n> slider.on_changed(update)plt.show()\n>\n> Actual outcome\n>\n>   File \"<ipython-input-52-b704c53e18d4>\", line 19, in <module>\n>     slider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max(),valinit=[0.0,0.0])\n>\n>   File \"/Users/Vincent/opt/anaconda3/envs/py38/lib/python3.8/site-packages/matplotlib/widgets.py\", line 778, in __init__\n>     self.set_val(valinit)\n>\n>   File \"/Users/Vincent/opt/anaconda3/envs/py38/lib/python3.8/site-packages/matplotlib/widgets.py\", line 915, in set_val\n>     xy[4] = val[0], .25\n>\n> IndexError: index 4 is out of bounds for axis 0 with size 4\n>\n> Expected outcome\n>\n> range slider with user initial values\n> Additional information\n>\n> error can be\n>\n>\n>     def set_val(self, val):\n>         \"\"\"\n>         Set slider value to *val*.\n>\n>         Parameters\n>         ----------\n>         val : tuple or array-like of float\n>         \"\"\"\n>         val = np.sort(np.asanyarray(val))\n>         if val.shape != (2,):\n>             raise ValueError(\n>                 f\"val must have shape (2,) but has shape {val.shape}\"\n>             )\n>         val[0] = self._min_in_bounds(val[0])\n>         val[1] = self._max_in_bounds(val[1])\n>         xy = self.poly.xy\n>         if self.orientation == \"vertical\":\n>             xy[0] = .25, val[0]\n>             xy[1] = .25, val[1]\n>             xy[2] = .75, val[1]\n>             xy[3] = .75, val[0]\n>             # xy[4] = .25, val[0]\n>         else:\n>             xy[0] = val[0], .25\n>             xy[1] = val[0], .75\n>             xy[2] = val[1], .75\n>             xy[3] = val[1], .25\n>             # xy[4] = val[0], .25\n>         self.poly.xy = xy\n>         self.valtext.set_text(self._format(val))\n>         if self.drawon:\n>             self.ax.figure.canvas.draw_idle()\n>         self.val = val\n>         if self.eventson:\n>             self._observers.process(\"changed\", val)\n>\n>\n> Operating system\n>\n> OSX\n> Matplotlib Version\n>\n> 3.5.1\n> Matplotlib Backend\n>\n> *No response*\n> Python version\n>\n> 3.8\n> Jupyter version\n>\n> *No response*\n> Installation\n>\n> pip\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <https://github.com/matplotlib/matplotlib/issues/22686>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AACHF6CW2HVLKT5Q56BVZDLVBJ6X7ANCNFSM5RMUEIDQ>\n> .\n> You are receiving this because you are subscribed to this thread.Message\n> ID: ***@***.***>\n>\n\nYes, i might have been too fast, cause it allows to skip the error but then it seems that the polygon is not right...\r\nLet me know if you know how this should be solved...\r\n![Capture d\u2019e\u0301cran, le 2022-03-22 a\u0300 23 20 23](https://user-images.githubusercontent.com/37241971/159617326-44c69bfc-bf0a-4f79-ab23-925c7066f2c2.jpg)\r\n\r\n\nSo I think you found an edge case because your valinit has both values equal. This means that the poly object created by `axhspan` is not as large as the rest of the code expects. \r\n\r\nhttps://github.com/matplotlib/matplotlib/blob/11737d0694109f71d2603ba67d764aa2fb302761/lib/matplotlib/widgets.py#L722\r\n\r\nA quick workaround is to have the valinit contain two different numbers (even if only minuscule difference)\nYes you are right!\r\nThanks a lot for digging into this!!\nCompare:\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nfig, ax = plt.subplots()\r\npoly_same_valinit = ax.axvspan(0, 0, 0, 1)\r\npoly_diff_valinit = ax.axvspan(0, .5, 0, 1)\r\nprint(poly_same_valinit.xy.shape)\r\nprint(poly_diff_valinit.xy.shape)\r\n```\r\n\r\nwhich gives:\r\n\r\n```\r\n(4, 2)\r\n(5, 2)\r\n```\r\n\nTwo solutions spring to mind:\r\n\r\n1. Easier option\r\nThrow an error in init if `valinit[0] == valinit[1]`\r\n\r\n2. Maybe better option?\r\nDon't use axhspan and manually create the poly to ensure it always has the expected number of vertices\nOption 2 might be better yes\n@vpicouet any interest in opening a PR?\nI don't think I am qualified to do so, never opened a PR yet. \r\nRangeSlider might also contain another issue. \r\nWhen I call `RangeSlider.set_val([0.0,0.1])`\r\nIt changes only the blue poly object and the range value on the right side of the slider not the dot:\r\n![Capture d\u2019e\u0301cran, le 2022-03-25 a\u0300 15 53 44](https://user-images.githubusercontent.com/37241971/160191943-aef5fbe2-2f54-42ae-9719-23375767b212.jpg)\r\n \n> I don't think I am qualified to do so, never opened a PR yet.\r\n\r\nThat's always true until you've opened your first one :). But I also understand that it can be intimidating.\r\n\r\n\r\n>  RangeSlider might also contain another issue.\r\n> When I call RangeSlider.set_val([0.0,0.1])\r\n> It changes only the blue poly object and the range value on the right side of the slider not the dot:\r\n\r\n\r\noh hmm - good catch! may be worth opening a separate issue there as these are two distinct bugs and this one may be a bit more comlicated to fix.\nHaha true! I might try when I have more time!\r\nThrowing an error at least as I have never worked with axhspan and polys.\r\nOk, openning another issue.\nCan I try working on this? @ianhi @vpicouet \r\nFrom the discussion, I could identify that a quick fix would be to use a try-except block to throw an error \r\nif valinit[0] == valinit[1]\r\n\r\nPlease let me know your thoughts.\nSure! ",
        "created_at": "2022-03-27T00:34:37Z",
        "test_patch": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1105,19 +1105,30 @@ def test_range_slider(orientation):\n     # Check initial value is set correctly\n     assert_allclose(slider.val, (0.1, 0.34))\n \n+    def handle_positions(slider):\n+        if orientation == \"vertical\":\n+            return [h.get_ydata()[0] for h in slider._handles]\n+        else:\n+            return [h.get_xdata()[0] for h in slider._handles]\n+\n     slider.set_val((0.2, 0.6))\n     assert_allclose(slider.val, (0.2, 0.6))\n+    assert_allclose(handle_positions(slider), (0.2, 0.6))\n+\n     box = slider.poly.get_extents().transformed(ax.transAxes.inverted())\n     assert_allclose(box.get_points().flatten()[idx], [0.2, .25, 0.6, .75])\n \n     slider.set_val((0.2, 0.1))\n     assert_allclose(slider.val, (0.1, 0.2))\n+    assert_allclose(handle_positions(slider), (0.1, 0.2))\n \n     slider.set_val((-1, 10))\n     assert_allclose(slider.val, (0, 1))\n+    assert_allclose(handle_positions(slider), (0, 1))\n \n     slider.reset()\n-    assert_allclose(slider.val, [0.1, 0.34])\n+    assert_allclose(slider.val, (0.1, 0.34))\n+    assert_allclose(handle_positions(slider), (0.1, 0.34))\n \n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n",
        "repo": "matplotlib/matplotlib",
        "problem_statement": "[Bug]: cannot give init value for RangeSlider widget\n### Bug summary\r\n\r\nI think `xy[4] = .25, val[0]` should be commented in /matplotlib/widgets. py\", line 915, in set_val\r\nas it prevents to initialized value for RangeSlider\r\n\r\n### Code for reproduction\r\n\r\n```python\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib.widgets import RangeSlider\r\n\r\n# generate a fake image\r\nnp.random.seed(19680801)\r\nN = 128\r\nimg = np.random.randn(N, N)\r\n\r\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\r\nfig.subplots_adjust(bottom=0.25)\r\n\r\nim = axs[0].imshow(img)\r\naxs[1].hist(img.flatten(), bins='auto')\r\naxs[1].set_title('Histogram of pixel intensities')\r\n\r\n# Create the RangeSlider\r\nslider_ax = fig.add_axes([0.20, 0.1, 0.60, 0.03])\r\nslider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max(),valinit=[0.0,0.0])\r\n\r\n# Create the Vertical lines on the histogram\r\nlower_limit_line = axs[1].axvline(slider.val[0], color='k')\r\nupper_limit_line = axs[1].axvline(slider.val[1], color='k')\r\n\r\n\r\ndef update(val):\r\n    # The val passed to a callback by the RangeSlider will\r\n    # be a tuple of (min, max)\r\n\r\n    # Update the image's colormap\r\n    im.norm.vmin = val[0]\r\n    im.norm.vmax = val[1]\r\n\r\n    # Update the position of the vertical lines\r\n    lower_limit_line.set_xdata([val[0], val[0]])\r\n    upper_limit_line.set_xdata([val[1], val[1]])\r\n\r\n    # Redraw the figure to ensure it updates\r\n    fig.canvas.draw_idle()\r\n\r\n\r\nslider.on_changed(update)\r\nplt.show()\r\n```\r\n\r\n\r\n### Actual outcome\r\n\r\n```python\r\n  File \"<ipython-input-52-b704c53e18d4>\", line 19, in <module>\r\n    slider = RangeSlider(slider_ax, \"Threshold\", img.min(), img.max(),valinit=[0.0,0.0])\r\n\r\n  File \"/Users/Vincent/opt/anaconda3/envs/py38/lib/python3.8/site-packages/matplotlib/widgets.py\", line 778, in __init__\r\n    self.set_val(valinit)\r\n\r\n  File \"/Users/Vincent/opt/anaconda3/envs/py38/lib/python3.8/site-packages/matplotlib/widgets.py\", line 915, in set_val\r\n    xy[4] = val[0], .25\r\n\r\nIndexError: index 4 is out of bounds for axis 0 with size 4\r\n```\r\n\r\n### Expected outcome\r\n\r\nrange slider with user initial values\r\n\r\n### Additional information\r\n\r\nerror can be removed by commenting this line\r\n```python\r\n\r\n    def set_val(self, val):\r\n        \"\"\"\r\n        Set slider value to *val*.\r\n\r\n        Parameters\r\n        ----------\r\n        val : tuple or array-like of float\r\n        \"\"\"\r\n        val = np.sort(np.asanyarray(val))\r\n        if val.shape != (2,):\r\n            raise ValueError(\r\n                f\"val must have shape (2,) but has shape {val.shape}\"\r\n            )\r\n        val[0] = self._min_in_bounds(val[0])\r\n        val[1] = self._max_in_bounds(val[1])\r\n        xy = self.poly.xy\r\n        if self.orientation == \"vertical\":\r\n            xy[0] = .25, val[0]\r\n            xy[1] = .25, val[1]\r\n            xy[2] = .75, val[1]\r\n            xy[3] = .75, val[0]\r\n            # xy[4] = .25, val[0]\r\n        else:\r\n            xy[0] = val[0], .25\r\n            xy[1] = val[0], .75\r\n            xy[2] = val[1], .75\r\n            xy[3] = val[1], .25\r\n            # xy[4] = val[0], .25\r\n        self.poly.xy = xy\r\n        self.valtext.set_text(self._format(val))\r\n        if self.drawon:\r\n            self.ax.figure.canvas.draw_idle()\r\n        self.val = val\r\n        if self.eventson:\r\n            self._observers.process(\"changed\", val)\r\n\r\n```\r\n\r\n### Operating system\r\n\r\nOSX\r\n\r\n### Matplotlib Version\r\n\r\n3.5.1\r\n\r\n### Matplotlib Backend\r\n\r\n_No response_\r\n\r\n### Python version\r\n\r\n3.8\r\n\r\n### Jupyter version\r\n\r\n_No response_\r\n\r\n### Installation\r\n\r\npip\n",
        "version": "3.5",
        "FAIL_TO_PASS": [
            "lib/matplotlib/tests/test_widgets.py::test_range_slider[horizontal]",
            "lib/matplotlib/tests/test_widgets.py::test_range_slider[vertical]"
        ],
        "PASS_TO_PASS": [
            "lib/matplotlib/tests/test_widgets.py::test_CheckButtons",
            "lib/matplotlib/tests/test_widgets.py::test_MultiCursor[False-True]",
            "lib/matplotlib/tests/test_widgets.py::test_MultiCursor[True-False]",
            "lib/matplotlib/tests/test_widgets.py::test_MultiCursor[True-True]",
            "lib/matplotlib/tests/test_widgets.py::test_TextBox[none]",
            "lib/matplotlib/tests/test_widgets.py::test_TextBox[toolbar2]",
            "lib/matplotlib/tests/test_widgets.py::test_TextBox[toolmanager]",
            "lib/matplotlib/tests/test_widgets.py::test_check_bunch_of_radio_buttons[png]",
            "lib/matplotlib/tests/test_widgets.py::test_check_radio_buttons_image[png]",
            "lib/matplotlib/tests/test_widgets.py::test_ellipse",
            "lib/matplotlib/tests/test_widgets.py::test_lasso_selector",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector[False]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector[True]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_box",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_redraw[False]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_redraw[True]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[False-1]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[False-2]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[False-3]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[True-1]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[True-2]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove[True-3]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove_first_point[False]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_remove_first_point[True]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_set_props_handle_props[False]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_set_props_handle_props[True]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_verts_setter[png-False]",
            "lib/matplotlib/tests/test_widgets.py::test_polygon_selector_verts_setter[png-True]",
            "lib/matplotlib/tests/test_widgets.py::test_rect_visibility[pdf]",
            "lib/matplotlib/tests/test_widgets.py::test_rect_visibility[png]",
            "lib/matplotlib/tests/test_widgets.py::test_rectange_add_remove_set",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_add_state",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_drag[False-new_center1]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_drag[True-new_center0]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_handles",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-0-10-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-0-10-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-1-10.5-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-1-10.5-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-1-11-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[0-10-1-11-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-0-10-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-0-10-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-1-10.5-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-1-10.5-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-1-11-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-10.5-1-11-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-0-10-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-0-10-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-1-10.5-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-1-10.5-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-1-11-data]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_minspan[1-11-1-11-pixels]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_center[False]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_center[True]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_square[False]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_square[True]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_square_center",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_square_center_aspect[False]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_resize_square_center_aspect[True]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_rotate[EllipseSelector]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_rotate[RectangleSelector]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector_ignore_outside[False]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector_ignore_outside[True]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector_onselect[False]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector_onselect[True]",
            "lib/matplotlib/tests/test_widgets.py::test_rectangle_selector_set_props_handle_props",
            "lib/matplotlib/tests/test_widgets.py::test_selector_clear[rectangle]",
            "lib/matplotlib/tests/test_widgets.py::test_selector_clear[span]",
            "lib/matplotlib/tests/test_widgets.py::test_selector_clear_method[rectangle]",
            "lib/matplotlib/tests/test_widgets.py::test_selector_clear_method[span]",
            "lib/matplotlib/tests/test_widgets.py::test_slider_horizontal_vertical",
            "lib/matplotlib/tests/test_widgets.py::test_slider_reset",
            "lib/matplotlib/tests/test_widgets.py::test_slider_slidermin_slidermax",
            "lib/matplotlib/tests/test_widgets.py::test_slider_slidermin_slidermax_invalid",
            "lib/matplotlib/tests/test_widgets.py::test_slider_valmin_valmax",
            "lib/matplotlib/tests/test_widgets.py::test_slider_valstep_snapping",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_add_state",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_bound[horizontal]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_bound[vertical]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_direction",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_drag[False]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_drag[True]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_ignore_outside[False]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_ignore_outside[True]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_onselect[False]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_onselect[True]",
            "lib/matplotlib/tests/test_widgets.py::test_span_selector_set_props_handle_props",
            "lib/matplotlib/tests/test_widgets.py::test_tool_line_handle"
        ],
        "environment_setup_commit": "de98877e3dc45de8dd441d008f23d88738dc015d",
        "patch": "diff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -813,7 +813,10 @@ def _update_val_from_pos(self, pos):\n             val = self._max_in_bounds(pos)\n             self.set_max(val)\n         if self._active_handle:\n-            self._active_handle.set_xdata([val])\n+            if self.orientation == \"vertical\":\n+                self._active_handle.set_ydata([val])\n+            else:\n+                self._active_handle.set_xdata([val])\n \n     def _update(self, event):\n         \"\"\"Update the slider position.\"\"\"\n@@ -836,11 +839,16 @@ def _update(self, event):\n             return\n \n         # determine which handle was grabbed\n-        handle = self._handles[\n-            np.argmin(\n+        if self.orientation == \"vertical\":\n+            handle_index = np.argmin(\n+                np.abs([h.get_ydata()[0] - event.ydata for h in self._handles])\n+            )\n+        else:\n+            handle_index = np.argmin(\n                 np.abs([h.get_xdata()[0] - event.xdata for h in self._handles])\n             )\n-        ]\n+        handle = self._handles[handle_index]\n+\n         # these checks ensure smooth behavior if the handles swap which one\n         # has a higher value. i.e. if one is dragged over and past the other.\n         if handle is not self._active_handle:\n@@ -904,14 +912,22 @@ def set_val(self, val):\n             xy[2] = .75, val[1]\n             xy[3] = .75, val[0]\n             xy[4] = .25, val[0]\n+\n+            self._handles[0].set_ydata([val[0]])\n+            self._handles[1].set_ydata([val[1]])\n         else:\n             xy[0] = val[0], .25\n             xy[1] = val[0], .75\n             xy[2] = val[1], .75\n             xy[3] = val[1], .25\n             xy[4] = val[0], .25\n+\n+            self._handles[0].set_xdata([val[0]])\n+            self._handles[1].set_xdata([val[1]])\n+\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n+\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n",
        "pr_link": "https://github.com/matplotlib/matplotlib/pull/22711"
    }
}